<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Edagarli&#39;s Blog</title>
  <subtitle>Only The Paranoid Survive</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.edagarli.com/"/>
  <updated>2016-09-24T12:47:00.000Z</updated>
  <id>http://blog.edagarli.com/</id>
  
  <author>
    <name>Edagarli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty的优化备记</title>
    <link href="http://blog.edagarli.com/2016/09/24/Netty%E7%9A%84%E4%BC%98%E5%8C%96%E5%A4%87%E8%AE%B0/"/>
    <id>http://blog.edagarli.com/2016/09/24/Netty的优化备记/</id>
    <published>2016-09-24T12:47:00.000Z</published>
    <updated>2016-09-24T12:47:00.000Z</updated>
    
    <content type="html">&lt;p&gt;1.当心“日志隐形杀手”&lt;/p&gt;
&lt;p&gt;通常情况下，大家都知道不能在Netty的I/O线程上做执行时间不可控的操作，例如访问数据库、发送Email等。但是有个常用但是非常危险的操作却容易被忽略，那便是记录日志。&lt;/p&gt;
&lt;p&gt;通常，在生产环境中，需要实时打印接口日志，其它日志处于ERROR级别，当推送服务发生I/O异常之后，会记录异常日志。如果当前磁盘的WIO比较高，可能会发生写日志文件操作被同步阻塞，阻塞时间无法预测。这就会导致Netty的NioEventLoop线程被阻塞，Socket链路无法被及时关闭、其它的链路也无法进行读写操作等。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;以最常用的log4j为例，尽管它支持异步写日志（AsyncAppender），但是当日志队列满之后，它会同步阻塞业务线程，直到日志队列有空闲位置可用，相关代码如下：&lt;/p&gt;
&lt;p&gt;synchronized (this.buffer) {&lt;br&gt;      while (true) {&lt;br&gt;        int previousSize = this.buffer.size();&lt;br&gt;        if (previousSize &amp;lt; this.bufferSize) {&lt;br&gt;          this.buffer.add(event);&lt;br&gt;          if (previousSize != 0) break;&lt;br&gt;          this.buffer.notifyAll(); break;&lt;br&gt;        }&lt;br&gt;        boolean discard = true;&lt;br&gt;        if ((this.blocking) &amp;amp;&amp;amp; (!Thread.interrupted()) &amp;amp;&amp;amp; (Thread.currentThread() != this.dispatcher)) //判断是业务线程&lt;br&gt;        {&lt;br&gt;          try&lt;br&gt;          {&lt;br&gt;            this.buffer.wait();//阻塞业务线程&lt;br&gt;            discard = false;&lt;br&gt;          }&lt;br&gt;          catch (InterruptedException e)&lt;br&gt;          {&lt;br&gt;            Thread.currentThread().interrupt();&lt;br&gt;          }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似这类BUG具有极强的隐蔽性，往往WIO高的时间持续非常短，或者是偶现的，在测试环境中很难模拟此类故障，问题定位难度非常大。这就要求读者在平时写代码的时候一定要当心，注意那些隐性地雷。&lt;/p&gt;
&lt;p&gt;2.TCP参数优化&lt;/p&gt;
&lt;p&gt;常用的TCP参数，例如TCP层面的接收和发送缓冲区大小设置，在Netty中分别对应ChannelOption的SO_SNDBUF和SO_RCVBUF，需要根据推送消息的大小，合理设置，对于海量长连接，通常32K是个不错的选择。&lt;/p&gt;
&lt;p&gt;另外一个比较常用的优化手段就是软中断，如图所示：如果所有的软中断都运行在CPU0相应网卡的硬件中断上，那么始终都是cpu0在处理软中断，而此时其它CPU资源就被浪费了，因为无法并行的执行多个软中断。&lt;/p&gt;
&lt;p&gt;大于等于2.6.35版本的Linux kernel内核，开启RPS，网络通信性能提升20%之上。RPS的基本原理：根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu。从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断运行在多个cpu上，从而提升通信性能。&lt;/p&gt;
&lt;p&gt;3.JVM参数&lt;/p&gt;
&lt;p&gt;最重要的参数调整有两个：&lt;/p&gt;
&lt;p&gt;-Xmx:JVM最大内存需要根据内存模型进行计算并得出相对合理的值；&lt;br&gt;GC相关的参数: 例如新生代和老生代、永久代的比例，GC的策略，新生代各区的比例等，需要根据具体的场景进行设置和测试，并不断的优化，尽量将Full GC的频率降到最低。&lt;/p&gt;
&lt;p&gt;4.内存池&lt;/p&gt;
&lt;p&gt;推送服务器承载了海量的长链接，每个长链接实际就是一个会话。如果每个会话都持有心跳数据、接收缓冲区、指令集等数据结构，而且这些实例随着消息的处理朝生夕灭，这就会给服务器带来沉重的GC压力，同时消耗大量的内存。&lt;/p&gt;
&lt;p&gt;最有效的解决策略就是使用内存池，每个NioEventLoop线程处理N个链路，在线程内部，链路的处理时串行的。假如A链路首先被处理，它会创建接收缓冲区等对象，待解码完成之后，构造的POJO对象被封装成Task后投递到后台的线程池中执行，然后接收缓冲区会被释放，每条消息的接收和处理都会重复接收缓冲区的创建和释放。如果使用内存池，则当A链路接收到新的数据报之后，从NioEventLoop的内存池中申请空闲的ByteBuf，解码完成之后，调用release将ByteBuf释放到内存池中，供后续B链路继续使用。&lt;/p&gt;
&lt;p&gt;如果觉得还不错，赏点酒钱！&lt;br&gt;&lt;img src=&quot;/images/aex068188cqwy9xbxa3oc07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1.当心“日志隐形杀手”&lt;/p&gt;
&lt;p&gt;通常情况下，大家都知道不能在Netty的I/O线程上做执行时间不可控的操作，例如访问数据库、发送Email等。但是有个常用但是非常危险的操作却容易被忽略，那便是记录日志。&lt;/p&gt;
&lt;p&gt;通常，在生产环境中，需要实时打印接口日志，其它日志处于ERROR级别，当推送服务发生I/O异常之后，会记录异常日志。如果当前磁盘的WIO比较高，可能会发生写日志文件操作被同步阻塞，阻塞时间无法预测。这就会导致Netty的NioEventLoop线程被阻塞，Socket链路无法被及时关闭、其它的链路也无法进行读写操作等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开通微信公众号</title>
    <link href="http://blog.edagarli.com/2016/07/15/%E5%BC%80%E9%80%9A%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    <id>http://blog.edagarli.com/2016/07/15/开通微信公众号/</id>
    <published>2016-07-15T14:11:09.000Z</published>
    <updated>2016-07-15T14:11:09.000Z</updated>
    
    <content type="html">&lt;p&gt;开始尝试在微信公众号写点文章了.&lt;/p&gt;
&lt;p&gt;我是李智(edagarli), 花名卤肉， 我会不定期分享一些技术，产品以及我创业方面的想法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开始尝试在微信公众号写点文章了.&lt;/p&gt;
&lt;p&gt;我是李智(edagarli), 花名卤肉， 我会不定期分享一些技术，产品以及我创业方面的想法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis之过期键删除策略</title>
    <link href="http://blog.edagarli.com/2016/06/08/Redis%E4%B9%8B%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/"/>
    <id>http://blog.edagarli.com/2016/06/08/Redis之过期键删除策略/</id>
    <published>2016-06-08T10:52:56.000Z</published>
    <updated>2016-06-08T11:40:16.000Z</updated>
    
    <content type="html">&lt;p&gt;如果一个键过期了，那么它什么时候会被删除呢？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;*定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 定时删除策略是对内存最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。  &lt;/p&gt;
&lt;p&gt;例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。&lt;/p&gt;
&lt;p&gt;除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式–无序链表，查找一个事件的时间复杂度为O(N) —- 并不能高效地处理大量时间事件。&lt;/p&gt;
&lt;p&gt;因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。&lt;/p&gt;
&lt;p&gt; 惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占的内存就不会释放。&lt;/p&gt;
&lt;p&gt;在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄露—-无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。&lt;/p&gt;
&lt;p&gt; 举个例子，对于一些和时间有关的数据，比如日志(log)，在某个时间之后，对它们的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户以为服务器已经自动将它们删除了，但实际上这些键仍然存在，而且键所占用的内存也没有释放，那么造成的后果肯定是非常严重的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*定期删除:每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 定期删除策略是前两种策略的一种整合和折中：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1. 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；

2. 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt; 定期删除策略的难点是确定删除操作执行的时长和频率：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1. 如果删除操作执行的太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。

2. 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt; 因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。简单说明下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查。过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来自《Redis设计与实现》读书笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果觉得还不错，赏点酒钱！&lt;br&gt;&lt;img src=&quot;/images/aex068188cqwy9xbxa3oc07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个键过期了，那么它什么时候会被删除呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx命令行配置</title>
    <link href="http://blog.edagarli.com/2016/06/08/Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.edagarli.com/2016/06/08/Nginx命令行配置/</id>
    <published>2016-06-08T05:54:19.000Z</published>
    <updated>2016-06-08T05:54:19.000Z</updated>
    
    <content type="html">&lt;p&gt;接下来,会记录下Nginx从基本到深入的一些东西.&lt;/p&gt;
&lt;p&gt;在linux中，需要使用命令来控制Nginx服务器的启动与停止，重载配置文件，回滚日志文件，平滑升级等行为。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1)默认启动方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;／usr/local/nginx/sbin/nginx
这时，会读取默认路径下的配置文件: /usr/local/nginx/conf/nginx.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)指定配置文件的启动方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -c /tmp/nginx.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3)指定安装目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -p /usr/local/nginx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4)全局配置项的启动方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /usr/local/nginx/sbin/nginx -g &amp;quot;pid /var/nginx/test.pid&amp;quot;
 -g参数约束的条件是指定的配置项不能与默认路径下的nginx.conf配置项冲突。
 -g启动的Nginx服务执行其他命令时，需要把－g参数也带上，否则可能出现配置项不匹配的情形。
比如：/usr/local/nginx/sbin/nginx -g &amp;quot;pid /var/nginx/test.pid;&amp;quot; -s stop
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5)测试配置信息是否有错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -t
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6)在测试配置阶段不输出信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -t -q
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7)显示版本信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -v
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8)显示编译阶段的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -V
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9)快速地停止服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -s stop
－s参数其实是告诉Nginx程序向正在运行的Nginx服务发送信号量，Nginx程序通过Nginx.pid文件中得到master进程的进程ID，再向运行中的master进程发送TREM信号来快速地关闭Nginx服务。
ps -ef | grep nginx
kill -s SIGTERM port或kill -s SIGINT port
其实得到的效果与-s stop一样的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;10) 优雅的停止服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;处理完当前所有请求再停止服务
/usr/local/nginx/sbin/nginx -s quit
或kill -s SIGQUIT &amp;lt;nginx master pid&amp;gt;
如果要优雅地停止worker进程：kill -s SIGWINCH &amp;lt;nginx worker pid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;11)使运行中的Nginx重读配置项并生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;／usr/local/nginx/sbin/nginx -s reload
或kill -s SIGHUP &amp;lt;nginx master pid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;12）日志文件回滚&lt;br&gt;    使用-s reopen参数可以重新打开日志文件，把当前日志文件改名或转移到其他目录进行备份，再重新打开时就会生成新的日志文件。这个功能使得日志文件不至于过大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;／usr/local/nginx/sbin/nginx -s reopen
或kill -s SIGUSR1 &amp;lt;nginx master pid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;13)平滑升级Nginx&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nginx支持不重启来完成新版本的平滑升级
kill -s SIGUSR2 &amp;lt;nginx master pid&amp;gt;
会将pid文件重命名，如将/usr/local/nginx/logs/nginx.pid重命名／usr/local/nginx/logs/nginx.pid.oldbin
启动新版本的Nginx，ps可以发现新旧的在同时运行
kill命令向旧版本的master进程发送SIGQUIT信号。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;14）显示命令行帮助 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;－h 或者？
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;如果觉得还不错，赏点酒钱！&lt;br&gt;&lt;img src=&quot;/images/aex068188cqwy9xbxa3oc07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;接下来,会记录下Nginx从基本到深入的一些东西.&lt;/p&gt;
&lt;p&gt;在linux中，需要使用命令来控制Nginx服务器的启动与停止，重载配置文件，回滚日志文件，平滑升级等行为。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.edagarli.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="nginx" scheme="http://blog.edagarli.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>混segmentfault 闯Hackathon 一心要做一款伟大产品的攻城狮</title>
    <link href="http://blog.edagarli.com/2016/04/13/%E6%88%91%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://blog.edagarli.com/2016/04/13/我的经历/</id>
    <published>2016-04-12T17:21:42.000Z</published>
    <updated>2016-04-12T17:21:42.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间,有些人问我技术经历.自己最近正好被记者采访.我正好借用下他发布的文章.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;李智，男，24岁，现为二维火研发团队成员。鄱阳湖边长大的他，鬓发不输谢霆锋，清秀堪比宋仲基。可这样的小鲜肉，花名却叫“卤肉”。&lt;/p&gt;
&lt;p&gt;跟大多数宅男程序猿相比，李智算是比较外向的。“我以前也很宅，是个闷葫芦，但后来经常逛社区，与人打交道多了，慢慢就变得外向。”混segmentfault，闯Hackathon（编程马拉松，又译为黑客松），怀着一颗不安分的心，他一直想做一款伟大的产品。&lt;/p&gt;
&lt;p&gt;▲李智&lt;br&gt;休学创业&lt;br&gt;一举拿下IDG创业大赛第一名&lt;/p&gt;
&lt;p&gt;一切源于兴趣。“高中那会儿，流行木马盗QQ等，感觉一个木马就能控制别人电脑很牛。”出于对网络安全的兴趣，高三毕业之后的那个暑假，他就开始自学计算机技术。上大学时，他开始系统学习编程。&lt;/p&gt;
&lt;p&gt;学计算机的同学通常分为两拨：一拨沉迷于游戏，一拨热衷于开发产品，李智属于后者。他把大多数课余时间都花在了学习和做产品上。&lt;/p&gt;
&lt;p&gt;在父母的计划中，他该安安分分读完本科，考个研究生，然后教书或继续做研究。但不安分的他，2012年看了“硅谷传奇”、“乔布斯传”等几部电影之后，萌生了休学创业的想法。“休学之前斗争了三个月。一开始，父母不理解，学校也坚决反对。后来，我先说服了父母，由父母去跟学校沟通。”&lt;/p&gt;
&lt;p&gt;李智休学后，就走上了创业路。他跟几个90后极客小伙伴一起搞了个工作室，大家在一起做自己喜欢做的事。2012年，他们的团队在IDG创业大赛上一举夺魁，获得了15万元的奖金，并获得了投资人青睐，成功融资100万元。他注册成立了公司，决定做一款浏览器。但由于团队整体运营能力偏弱，做这款产品的时机也不是很对，公司经营情况并不理想。后来，李智因为种种原因离开了公司。&lt;/p&gt;
&lt;p&gt;2014年，李智通过缘创派平台寻找合伙人创业过程中结识了新的小伙伴，又开始了新的创业。作为团队技术合伙人，李智负责产品开发任务。“我们一开始做‘打分吧’，一款服装搭配指导的社交APP，后来又升级为‘私搭’，但总感觉还没有抓住核心。后来，公司资金链出了问题，团队就解散了。”之后，李智加入二维火，一直从事研发工作至今。&lt;/p&gt;
&lt;p&gt;混社区、爱开源、爱“跑马”&lt;br&gt;一直在为做好产品做准备&lt;/p&gt;
&lt;p&gt;连续创业多年来，李智觉得自己是在实践中摸爬滚打过来，基本上什么坑都走过了。“我的最终目的依然是做一款好产品。让所有人都用自己做的产品是不是很爽？”所以，他长年混迹“segmentfault”、“v2ex”等社区，喜欢写博客开源，还经常参加Hackathon。“我一直都在为自己的梦想做准备。”&lt;/p&gt;
&lt;p&gt;在交流论坛上，李智主要在技术交流板块回答提问。他觉得，回答问题也是一个梳理技术的过程，能巩固技术，还能在上面发现一些新的问题，在以后的实践过程中就有效地避免类似的坑。“曾经一天之内在‘segmentfault’上回答了十多个问题，获得200多声望点，这个数字算是比较高的了。”&lt;/p&gt;
&lt;p&gt;除了混社区，他也喜欢写博客开源，架构开源、产品开源，让大家一起学习探讨，在探讨中提升自己的技术。“我很大一部分技术方面的提高都是在开源中获得的。”他说，“我曾做了一个小插件‘github’，帮别人快速搜索定位代码的。开源之后，别人发现了BUG，觉得代码不优美，使用也不太方便，我就不断去改进完善。这样一来，以后做产品的时候考虑问题也更全面了。”&lt;/p&gt;
&lt;p&gt;有空时，他也经常参加Hackathon，乐在其中。一般都是周末的两天时间，周六上午讲解一下，下午开始做，晚上熬通宵，到周日上午把产品做出来，下午由大牛进行评论。他觉得，这样的活动好处巨大，完善自己的技术，增加人脉，增加自己想法和产品的曝光度，一举多得。&lt;/p&gt;
&lt;p&gt;到现在为止，李智已经做了不少产品，包括“打分吧”、“私搭”、“易停车”等。“虽然‘让所有人都用自己做的产品’的梦想还未实现，但我一直在探索中逐渐接近这个梦想。”&lt;/p&gt;
&lt;p&gt;他发布文章的原文链接：&lt;a href=&quot;http://t.cn/RqxsgzI&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://t.cn/RqxsgzI&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间,有些人问我技术经历.自己最近正好被记者采访.我正好借用下他发布的文章.&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.edagarli.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="经历" scheme="http://blog.edagarli.com/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>调用超时监控组件开源</title>
    <link href="http://blog.edagarli.com/2016/04/04/%E8%B0%83%E7%94%A8%E8%B6%85%E6%97%B6%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%BC%80%E6%BA%90/"/>
    <id>http://blog.edagarli.com/2016/04/04/调用超时监控组件开源/</id>
    <published>2016-04-04T07:19:22.000Z</published>
    <updated>2016-04-04T07:19:22.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;调用超时监控组件( &lt;a href=&quot;https://github.com/2-dfire/twodfire-monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/2-dfire/twodfire-monitor&lt;/a&gt; )&lt;br&gt;这是我公司内部使用的超时监控组件，现在开源出来。对于中小型企业来说，已经完全满足了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;当某个action或接口执行超过设定阈值时将把调用栈的各个步骤开销打印出来。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;你可以直接下载源码或者直接使用jar (&lt;a href=&quot;https://github.com/2-dfire/twodfire-monitor/releases/tag/1.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/2-dfire/twodfire-monitor/releases/tag/1.0&lt;/a&gt; )&lt;/li&gt;
&lt;li&gt;配置文件（具体表达式自己根据项目需要配置）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;bean id=&amp;quot;monitorAround&amp;quot; class=&amp;quot;com.twodfire.timerMonitor.monitor.MonitorAround&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;property name=&amp;quot;maxTime&amp;quot; value=&amp;quot;300&amp;quot;/&amp;gt;&amp;lt;!-- 最大的超时时间--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;aop:config&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;aop:aspect id=&amp;quot;testAspect&amp;quot; ref=&amp;quot;monitorAround&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;aop:pointcut id=&amp;quot;timeMonitorPointcut&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  expression=&amp;quot;execution(* *..service*..*(..))&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;aop:around pointcut-ref=&amp;quot;timeMonitorPointcut&amp;quot; method=&amp;quot;watchPerformance&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/aop:aspect&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/aop:config&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/edagarli/monitor-example/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/edagarli/monitor-example/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;contact-me&quot;&gt;&lt;a href=&quot;#contact-me&quot; class=&quot;headerlink&quot; title=&quot;contact me&quot;&gt;&lt;/a&gt;contact me&lt;/h2&gt;&lt;p&gt;Weibo: &lt;a href=&quot;http://weibo.com/edagarli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@edagarli&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开源协议&quot;&gt;&lt;a href=&quot;#开源协议&quot; class=&quot;headerlink&quot; title=&quot;开源协议&quot;&gt;&lt;/a&gt;开源协议&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/2-dfire/twodfire-monitor/blob/master/LICENSE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MIT&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;调用超时监控组件( &lt;a href=&quot;https://github.com/2-dfire/twodfire-monitor&quot;&gt;https://github.com/2-dfire/twodfire-monitor&lt;/a&gt; )&lt;br&gt;这是我公司内部使用的超时监控组件，现在开源出来。对于中小型企业来说，已经完全满足了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;当某个action或接口执行超过设定阈值时将把调用栈的各个步骤开销打印出来。&lt;/p&gt;
    
    </summary>
    
      <category term="开源项目" scheme="http://blog.edagarli.com/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="组件" scheme="http://blog.edagarli.com/tags/%E7%BB%84%E4%BB%B6/"/>
    
      <category term="监控超时" scheme="http://blog.edagarli.com/tags/%E7%9B%91%E6%8E%A7%E8%B6%85%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>创业就像是玩LOL游戏</title>
    <link href="http://blog.edagarli.com/2016/04/01/%E5%88%9B%E4%B8%9A%E5%B0%B1%E5%83%8F%E6%98%AF%E7%8E%A9LOL%E6%B8%B8%E6%88%8F/"/>
    <id>http://blog.edagarli.com/2016/04/01/创业就像是玩LOL游戏/</id>
    <published>2016-03-31T17:50:25.000Z</published>
    <updated>2016-03-31T17:50:25.000Z</updated>
    
    <content type="html">&lt;p&gt;我想很多人都玩过LOL游戏。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;刚开始玩的时候，可能你觉得LOL还是需要点运气的，因为你匹配到的队友太坑了，导致你直接输掉比赛。&lt;/p&gt;
&lt;p&gt;但是要不了多久，你就会发现，就算你队友不坑，当你一旦跟高手对阵，当对手观察过、练习过、深思熟虑过。你几乎每盘都会输。事实上，开局不久之后你就会发现自己处于难以翻盘的局面。遇到这种情况，我一般选择20投。&lt;/p&gt;
&lt;p&gt;结果你会发现，LOL远不只是个靠运气的游戏。要玩得好，你需要练习，学习，需要计算（大招用了没，闪现交了没，TP还没有没，等等），需要付出努力，也需要更多经验意识（比如插眼）。&lt;/p&gt;
&lt;p&gt;你也许已经看出我想说的了：创业的过程也是这样，什么东西都需要你去学习。 &lt;/p&gt;
&lt;p&gt;在LOL里，哪怕是个菜鸟，只要你每周花点时间练习，只要资质不是太差，你必定能在很短的时间内逐步提高，或者至少能摆脱一直被虐的局面（以我个人的经验来看）。&lt;/p&gt;
&lt;p&gt;但是对于创业公司来说，哪怕是那些已经做得有声有色的项目，都没有这样的 “必定”。哪怕之前有过成功经验也无法保证什么，市场是瞬息万变的（曾经B轮拿到3000万美元融资的蜜淘，最近还不是倒闭了) 。&lt;/p&gt;
&lt;p&gt;创业是漫长的过程，就像游戏一样，需要你好好去运营，面对未知的变化。比如：突如其来的打野gank。可能今天融资是重点，明天忙着招聘面试，后天又要为租办公室搞得焦头烂额。&lt;/p&gt;
&lt;p&gt;LOL比赛中有很多套路。比如：传送门加号令之旗。这些都是从对战中研究出来的。创业的世界里，也一样，各种方法论简直满地都是。我听过 “别要太多钱，够用就好” 和 “能拿的钱就拿”，或者 “你要么成功要么烧光钱最后失败，不管结果是哪种，你都不用担心股权稀释” 和 “如果你不小心，到最后会被稀释出自己的公司”，以及 “初创期间，你本人是你能请得起的最好的员工” 和 “在早期唯一值得花钱的事情是创始团队以外的人才引进”。最后还有 “公司地点在哪里无所谓” 和 “如果你不把公司开在一线城市，没人会愿意为你工作” 之类的，等等等等。&lt;/p&gt;
&lt;p&gt;LOL比赛最后谁能获胜？这真看不出来，只能说相对有优势。除了避免犯错，努力点。创业者还能做什么？鸡汤和方法论很多，但很多都相互矛盾。真正的“创业大师”是不存在的。几乎所有成功的创业者都会告诉你，他们一路走来，运气是多么重要。&lt;/p&gt;
&lt;p&gt;换个角度看待你身边的每件事，你会发现不一样。&lt;/p&gt;
&lt;p&gt;题外话: 最近发起了一个项目,是关于&lt;a href=&quot;https://github.com/edagarli/howto-get-users&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;初创公司如何获取用户&lt;/a&gt;(&lt;a href=&quot;https://github.com/edagarli/howto-get-users&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/edagarli/howto-get-users&lt;/a&gt;) ,希望能帮助创业不易的你们。&lt;/p&gt;
&lt;p&gt;##contact me&lt;/p&gt;
&lt;p&gt;Weibo: &lt;a href=&quot;http://weibo.com/edagarli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@edagarli&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我想很多人都玩过LOL游戏。&lt;/p&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.edagarli.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="创业" scheme="http://blog.edagarli.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们擅长模仿而不善于创造</title>
    <link href="http://blog.edagarli.com/2016/03/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E6%93%85%E9%95%BF%E6%A8%A1%E4%BB%BF%E8%80%8C%E4%B8%8D%E5%96%84%E4%BA%8E%E5%88%9B%E9%80%A0/"/>
    <id>http://blog.edagarli.com/2016/03/30/为什么我们擅长模仿而不善于创造/</id>
    <published>2016-03-30T13:56:31.000Z</published>
    <updated>2016-03-30T13:56:31.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;ps: 最近在写Web框架，同时也在用ReactNative写一个OS X桌面应用。突然发现不管是框架，还是应用，很多部分都是在模仿别人，借鉴别人的思想，这本正常。但我回想起我折腾产品这么多年，很少有批判性思维和独创性思维，不禁很难受。随之引出下面的话题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 据报道，有一位游客在国外市场拍一件自制的工艺品，当对方得知是中国人后当即拒绝，说你们会模仿的。我有一个朋友专门能把德国的仪器拆开后进行模仿，而且功能不差，很赚钱的行业。但是我们国家所急需的创造性人才却是奇缺，这与体制环境和教育都有着密切的正相关。正如著名的钱学森之问，“为什么我们的学校总是培养不出杰出人才？”&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先是体制的外行领导内行，这是我们的光荣传统，从民国时期的军阀开始，美国西点军校和法国圣西尔军校的毕业生就只能当参谋长，而不能领军。到现代就更严重了，著名演员赵丹是在建国前出的名，建国后只演过少数的几个电影，文革开始后一直到1980年逝世，竟然一部电影都没有演成，他的文章“管得太具体，文艺没希望”成为了他的临终名言。教授不治校、专家不参政，说不定从哪里冒出一个人就来当市长，与市民哪里会有双向的信任？那天一个出租车司机说，现在的市长敢单独出来拎着筐买菜吗？我真的很佩服草民的思维，往往是剃刀定律一针见血。美国的市民可以预约州长见面，你能见到市长省长吗？连大门都进不去。瞎指挥带来的后果就是严重的资源浪费和时间消耗，到处学习取经重复循环，承接高层活动充斥政绩，没有自己也不会有自己的思考与创造。&lt;/p&gt;
&lt;p&gt;胡适曾说：“一个肮脏的国家，如果人人讲规则而不是谈道德，最终会变成一个有人味儿的正常国家，道德自然会逐渐回归； 一个干净的国家，如果人人都不讲规则却大谈道德，谈高尚，天天没事儿就谈道德规范，人人大公无私，最终这个国家会堕落成为一个伪君子遍布的肮脏国家。”&lt;br&gt;其次是环境的不支持基础研究，在上海研究所的博士毕业之后每月也就几千块钱，而到重点中学当教师可以拿到一万多元，所以才有程代展的学生放弃留美博士后而应聘中学，事实上很多学习基础科学的人最后都以教师职业为终结者。与其24小时没有场合地思考研究，还不如做家教挣钱快，即使鞍山补课的市价不也在90分钟500元到1500元之间的幅度吗？所以学生考上南开大学数学专业、南京大学化学专业、中科大学物理专业，除了少数人安贫乐道之外，最终都会放弃基础科学研究，不是改行就是当中学教师靠中考高考盈利吃饭，而这类寒门学子以农村家长不明白报考居多。实际上男生要想工作好找一些，上一个杭州电子科技大学的计算机工程就都解决了。（这是edagarli的母校，当然就是我的，嘿嘿。）&lt;br&gt;最后就是教育的功利性。北大教授钱理群曾说起恩师王瑶，那时每周六他都去王瑶家中听王瑶谈话，他戏说自己就是王瑶的大烟斗熏出来的。无独有偶，李政道的导师是芝加哥大学的著名科学家费米，每周也是用半天时间和他讨论，有一次费米问他太阳中间的温度是多少？李政道回答后，费米马上问：“你怎么知道的？”李说是文献上看来的，费米却说：“这不行，你一定要自己思考和估计，你不能这样接受人家的结论。”并放下手中的重要实验和李政道一起设计制造测量工具。这样的教育一去不复返了，这种教育无痕的讨论正在被作态的做法所遮蔽，正如岳南在《南渡北归》封面所言：“大师远去，再无大师”。&lt;/p&gt;
&lt;p&gt;我们现在的教育只注重对信息的知道和理解，而不具备批判性思维和独创性思维。为什么人要具有创造性呢？在21世纪我们人类面临四个大问题无法解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）电磁力、强力和弱力其作用在理论上是对称的，但实验结果却不对称，也正因为不对称所以我们才存在，否则就会因为正负粒子的相遇而湮灭。&lt;/li&gt;
&lt;li&gt;2）所有的基本粒子共有12种，1964年美国盖尔曼提出夸克模型（夸克取自爱尔兰作家乔伊斯所作长诗中一种神鸟的叫声），认为中子与质子由u、d、s 三种夸克及反夸克组成，后来又陆续发现c、b、t 夸克及其反夸克，一共12种，但是单独都看不见，这就是所谓“夸克禁闭”，这是一个大谜。&lt;/li&gt;
&lt;li&gt;3）95%以上的暗物质不是我们所知道的，也就是说我们是少数派，在这个宇宙上多数的东西不是我们和我们所见的。&lt;/li&gt;
&lt;li&gt;4）宇宙中类星体大约有100万之多，其中“爱因斯坦十字架”离我们80亿光年，但能量是太阳的10的16次方，远远超过太阳能的能量，但却不是我们所知的。这些问题好像离我们很远，其实是很近的，正因为量子力学的诞生，才会有今天的核能、激光、超导体和计算机。从哲学上，这些也正是人存在的意义和我们将去何方的本质问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而我们现在的计算和测量的思想方法已经解决不了这些问题，并且现有的工具知识与生物的发展也不完全一致。因此人类、世界和国家都需要创造型人才，只有从哲学思想、艺术对人脑的激发、基础科学研究全面联合的突破，才能应对世纪发展，使工业持续进化，使国家走到世界强国的前列，完成宇宙赋予人类的伟大使命。而只会做题纸，满足于小技巧、窄视野的教育，只能造就功利性的模仿性人才。放弃了人类应该掌握的普世公民教育、哲学流派对世界的认知、不作为敲门砖的艺术——真正热爱的美术、音乐与诗歌，手工制作、科普好奇心的激发等必须的教育，公民的素质低下就会成为必然的结果。&lt;/p&gt;
&lt;p&gt;1932年美国安德逊发现了狄拉克方程式所预言的正电子；1865年麦克斯韦方程式虽然只有四个微分方程组成，但却对20世纪产生了重大的影响，尽管他本人也不知的两个对称重要性要经过半个多世纪才被人们所认识；而开普勒的行星椭圆形轨道认知完全是唯象的，正如后来的普朗克常数，完全不是物质对意识的结果，这是一元唯心论的胜利；A·Pope在牛顿去世后写了一句话：“自然与自然规律为黑暗隐蔽，上帝说，让牛顿来！一切遂成光明。”&lt;br&gt;奥本·海默曾说：“那个时候在讨论时，有时候有些畏惧感。”科学家们对量子力学的畏惧感是指他们发现了不应该为凡人所了解的东西，牛顿晚年皈依宗教也是如此，这个世界最后无法解释的原因、最后的终极真理也许在宗教，这也许是物理学的最后归宿。&lt;/p&gt;
&lt;p&gt;由此看来，我们现在的教育不是很可笑吗？只是一场劳而无功的荒诞剧而已。&lt;/p&gt;
&lt;p&gt;##contact me&lt;/p&gt;
&lt;p&gt;Weibo: &lt;a href=&quot;http://weibo.com/edagarli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@edagarli&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ps: 最近在写Web框架，同时也在用ReactNative写一个OS X桌面应用。突然发现不管是框架，还是应用，很多部分都是在模仿别人，借鉴别人的思想，这本正常。但我回想起我折腾产品这么多年，很少有批判性思维和独创性思维，不禁很难受。随之引出下面的话题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 据报道，有一位游客在国外市场拍一件自制的工艺品，当对方得知是中国人后当即拒绝，说你们会模仿的。我有一个朋友专门能把德国的仪器拆开后进行模仿，而且功能不差，很赚钱的行业。但是我们国家所急需的创造性人才却是奇缺，这与体制环境和教育都有着密切的正相关。正如著名的钱学森之问，“为什么我们的学校总是培养不出杰出人才？”&lt;/p&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.edagarli.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="感想" scheme="http://blog.edagarli.com/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>如何获取用户</title>
    <link href="http://blog.edagarli.com/2016/03/23/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7/"/>
    <id>http://blog.edagarli.com/2016/03/23/如何获取用户/</id>
    <published>2016-03-23T05:44:17.000Z</published>
    <updated>2016-03-23T05:44:17.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;“在现代商业世界里，当一个才华横溢的创造者是没用的，除非你能同时把你创造的东西推销出去。”&lt;br&gt;——大卫·奥格威&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到种子投资的创业公司，第一个挑战就是把产品做出来，不少产品并未问世就夭折了，或者找外包公司做的 bug 满天飞的产品，能组一个靠谱的团队，把产品按照自己想象开发出来，实属不易。当这个挑战跨过去之后，就要开始找用户，不管用什么办法必须拿到 10 万用户，然后才有机会有下一轮融资，否则基本就拜拜了，至少有 80%的公司没有走过这一道坎。&lt;/p&gt;
&lt;p&gt;初创公司当产品初步完成后，就要开始找用户。当然，行业人脉和媒体关系极好，产品上线，立即吸引媒体纷纷专注并报道，或者融资能力极强，有足够多的钱可以做推广，这样的公司相对获取用户就更容易些。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;筛选你的种子用户&quot;&gt;&lt;a href=&quot;#筛选你的种子用户&quot; class=&quot;headerlink&quot; title=&quot;筛选你的种子用户&quot;&gt;&lt;/a&gt;筛选你的种子用户&lt;/h2&gt;&lt;p&gt;早期种子用户的质量将决定产品初期的氛围、运营走向，影响产品日后的发展策略。早期用户选得不够精准，可能会影响产品发展的速度和路径。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在互联网产品筛选种子用户的案例中，Facebook的做法广为人知。这家起源于哈佛大学校园的全球最大社交网站，在上线之初仅对常青藤大学的学生开放，随后逐渐向附近学校乃至全美、全世界拓展。这一聪明的策略帮助其在初期积累了大量的高质量种子用户，也勾起了外部世界融入这个精英社交圈的兴趣，为日后向普罗大众扩张奠定了牢靠的基础。&lt;/li&gt;
&lt;li&gt;在面向大众的社交产品中，高质量的女性往往是重要的种子用户群体。微信的张小龙曾经说过：如果你不了解女性，你将失去一半以上的用户（在他的推荐书单中包含《女性的起源》这样专门从进化学角度探讨女性的著作）。对于女性用户而言，营造良好的社区氛围，能使她们获得安全感与归属感，因此更加愿意展示自我，不吝与其他人的交流互动。而活跃的女性用户群体，则能激发带动更多的男性用户涌入进来，参与社区另一半的构建。于是社交生态就这样建立了起来。有的交友产品深谙此中之道，还会专门深入艺术高校花钱雇佣美女们来使用产品，希望通过打美女牌带给其他新用户们良好的第一印象。&lt;/li&gt;
&lt;li&gt;在号称“得屌丝者得天下的”互联网行业，知乎早期的发展策略走的是反其道而行之的精英路线。它采用了严格的邀请和审核机制，李开复、徐小平、雷军等互联网大佬和一批投资圈、媒体圈的从业者成为了它的种子用户。这从根源上奠定了知乎的调性，也使它在圈内迅速成为话题产品，一码难求。有幸受邀加入知乎的用户们谨言慎行，创造了一批高质量的内容。&lt;/li&gt;
&lt;li&gt;动漫爱好者的聚集地——哔哩哔哩弹幕视频网为了过滤出高质量的早期内容贡献者，维持社区的健康生态，采用了一套答题机制来拦截不够“资深”的动漫爱好者，滤出真正了解和热爱动漫作品的达人。每次系统会随机从题库中抽选出100道题，这些题目颇有一定难度，想要答对60道题从而晋级绝非易事。&lt;/li&gt;
&lt;li&gt;小米公司早在自家手机推出前，就通过发布MIUI积累到一批种子用户。当时小米的做法是从竞品的网站精心筛选并主动邀请来一批人，请他们试用仍在不断完善中的MIUI，听取反馈意见，并将他们留在自家的论坛里。2010年8月16日，MIUI第一版内测正式开启时，小米特地将这100个种子用户的ID写到了开机画面上以表达谢意。这100个用户被小米亲切地称为“100个梦想的赞助商”，还以此为题材专门拍摄了微电影。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;别放太多预算在公开市场推广&quot;&gt;&lt;a href=&quot;#别放太多预算在公开市场推广&quot; class=&quot;headerlink&quot; title=&quot;别放太多预算在公开市场推广&quot;&gt;&lt;/a&gt;别放太多预算在公开市场推广&lt;/h2&gt;&lt;p&gt;公开市场指的是，所有人都知道的渠道：应用市场排名、刷榜、积分墙、微博粉丝通、腾讯广点通等，主要原因是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、产品初期各方面都不够完善，转化率、活跃度都是比较低的状态，花钱带来的用户难以留存，不如先把产品做好，或是把钱放在提高创始团队福利上，以提升效率。有的创业者一下子花掉公司 10%的钱做推广，是很危险的。&lt;/li&gt;
&lt;li&gt;2、公开市场价格较为透明，所有公司做市场的人都盯着，价格较高，即使通过很大努力，ROI 可以做到行业平均的 1.5 倍，但仍然很贵，尤其对于没有收入、商业模式还不清晰的产品&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;从最笨的事情做起&quot;&gt;&lt;a href=&quot;#从最笨的事情做起&quot; class=&quot;headerlink&quot; title=&quot;从最笨的事情做起&quot;&gt;&lt;/a&gt;从最笨的事情做起&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在创立聚美优品之前，三位联合创始人先后尝试过游戏广告和团购项目。在业务不见起色、天使投资捉襟见肘的低谷中，三人一拍大腿，决定切入女性电商，从化妆品中谋求生存的机会。他们用两天时间迅速设计了新标志，把网站雏形搭建起来。由于没有预算邀请达人来参与宣传，更无法砸钱大规模地搞市场营销，于是几个做互联网的大老爷们开始自己研究起化妆品的使用心得。创始人戴雨森在人人网上注册了一个女性马甲，伪装成具有多年BB霜使用经验的美妆达人，写了一篇软文告诉大家BB霜是什么，有多少种，如何判别优劣及选购等。这篇文章获得了几十万次阅读。当时顺着文末推广链接一路找来的顾客，为他们贡献了几十万的销售额。&lt;br&gt;女人是视觉性的动物。那时候，其他的化妆品网站依靠供应商资源的强势，从价格上打压对手，忽略了网站的用户体验，许多宣传图既不清晰也不真实。为了激发网站访客的购买欲，聚美优品的几位创始人在办公室里单独辟出了一个工位，架起白色的隔板，把所有的化妆品摆在这个简易的“摄影棚”中，一件一件用照相机拍摄下来，并在电脑中精细修图，才传到页面上，配合口语化的商品描述，营造出一种值得推荐的品质感。&lt;/li&gt;
&lt;li&gt;作为被美国著名创业孵化器Y Combinator孵化的第一家中国团队，Strikingly能帮助用户简单快速地创建美观、适应移动端网站的在线工具。在产品上线之初，Strikingly并不急于铺开大范围的推广，而是专注于找到一百个“超级粉丝”，做出他们真正热爱的产品。筛选超级粉丝的方法很简单，就是一个个询问用户：如果明天没有Strikingly的产品了，你的感觉会如何？如果有用户回答称自己的工作或生活将受到很大影响，并且愿意通过付费等方式让网站维持下去，这个人就是超级粉丝。&lt;/li&gt;
&lt;li&gt;为此Strikingly寻访了公司周围所有的学校社团和创业公司，邀请他们用自己的产品。创始人David Chen在Facebook上添加了2000多名用户，每天泡在Facebook上和他们聊天，聆听产品反馈。有时候，他们也会邀请用户出来喝茶聊天，成为生活中的挚友。在一次出席东京的演讲时，David索性住到了用户的家里，并在那里举办了第一个“超级粉丝”的聚会。这些超级用户不但在产品初期贡献了许多宝贵意见，还把产品主动介绍给其他人，甚至尽责地顶替客服团队解答他人在使用中的困扰。这一切让前期付出大量精力在用户关系维护上的Strikingly团队成员们极为感动。&lt;/li&gt;
&lt;li&gt;网易旗下的有道云笔记，在推出协作版产品时首先拉来公司内部的50个员工每天高强度使用，不断提需求和反馈问题。在产品形态初见端倪后，他们又发布了小范围使用版，邀请来近百位意见领袖和旧版本的核心用户体验。随后的公测版正式对外发布阶段，有道云协作团队制作了一个审核流程严格的内测邀请页面，通过论坛和邮件抛出橄榄枝，一天之内收到了14000多个参与测试的请求。所有获得邀请的用户在专门搭建的反馈协作群里提问质询，接受产品经理和技术人员的实时回复解答。这批种子用户后来成为了有道云协作的义务推广员，就连骨灰级的竞品用户最后也纷纷选择倒戈。&lt;/li&gt;
&lt;li&gt;同样从“笨”办法做起的还有国外的共享经济代表——从事房屋出租服务的Airbnb。2009年时，他们每周的营收仅为200美元，公司的发展遭遇瓶颈。创始人一一翻阅网站上房源的配图，发现那些随便用手机拍出来的照片根本不具有什么吸引力，难怪顾客不愿意买单。他们试着向房东传达照片质量的重要性，也曾想过做一个拍照的教学手册来帮助房东们提升拍照水平，但都不太奏效。最后，他们索性租了一台昂贵的相机，挨家挨户上门去帮房东拍照，替他们把挂在网站上的旧照片更换成漂亮的新照片。一周之后，效果立竿见影，网站的营收立刻从200美元上涨到了400美元。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何从社交网络获取海量用户&quot;&gt;&lt;a href=&quot;#如何从社交网络获取海量用户&quot; class=&quot;headerlink&quot; title=&quot;如何从社交网络获取海量用户&quot;&gt;&lt;/a&gt;如何从社交网络获取海量用户&lt;/h2&gt;&lt;p&gt;平台级的社会化网站，不仅为每一个鲜活的线下个体建立了赛博空间内对应的映射，同时也为人们创造了自我表达、情绪宣泄的出口，完成从“自我”到“本我”去伪存真的过程。人们在社交网络上花费的时间与日俱增，由此带来庞大活跃的用户量、成熟的关系链和丰富的行为数据，为初创公司获取目标用户创造了条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大洋彼岸的另一家游戏公司Zynga凭借与Facebook的深度整合，取得了值得瞩目的成就。这是一家创建于2007年7月的公司，总部位于旧金山Potrero Hill附近的Chip Factory。有过三次惨痛失败创业经历、曾遭遇过将近20个项目失败的马克·平卡斯（Mark Pincus），以自己的斗牛犬为新公司命名。这一次重新起航，他敏锐嗅到了一个月前Facebook在F8大会上公布的开放平台计划的潜在机会，并且孤注一掷地将赌注押在了自身业务与平台的整合上。&lt;br&gt;Zynga相继发布了德州扑克、黑帮战争、美版开心农场、好友填字等社交游戏。开心农场上线一周后活跃用户达到270万人，随后的城堡小镇将纪录刷新至500万人，而前线小镇更是在2010年6月9日发布后的大约五周时间里，将活跃用户数拉升至了2000万人。这一款又一款旗舰产品不仅占据了超过一半的Facebook游戏用户，最夸张的时候甚至霸占了热门游戏排行榜前10名中的9个席位。在获得首轮融资的2008至2011年间，Zynga的营收增长了58倍，年化增长率达177％，月均活跃用户从2009年三季度的0.99亿人增长至2012年5月的2.65亿人，日收入轻松突破千万美元。随后顺理成章地上市，使之步入平视EA、动视等游戏巨头的行列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;用数据抓取“借鸡下蛋”&quot;&gt;&lt;a href=&quot;#用数据抓取“借鸡下蛋”&quot; class=&quot;headerlink&quot; title=&quot;用数据抓取“借鸡下蛋”&quot;&gt;&lt;/a&gt;用数据抓取“借鸡下蛋”&lt;/h2&gt;&lt;p&gt;人工采集和录入标准化的数据是一项耗时费力的工作。聪明的增长黑客自然能想到办法来一劳永逸，那就是数据抓取。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2010年9月底，微软正式宣布终结空间主页服务（Windows Live Spaces）。在国外，3000万用户将被强制迁移到主流的独立博客服务平台WordPress.com。而在国内，微软选择与新浪合作，计划在“十一”国庆假期后向用户提供官方迁移工具，将用户日志、图片、评论、朋友关系等无缝转至新浪博客。&lt;br&gt;消息公布后，网易博客反应迅速，立即抢在新浪行动之前宣布特别开启“一键搬家”的绿色通道，欢迎Live Spaces的用户选择网易博客安家。整个搬家操作只需两步：先输入原Live Space空间地址，再输入网易博客账号及密码，就能进入搬家程序，系统自动导入日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;内容营销：打造持续输出的传播引擎&quot;&gt;&lt;a href=&quot;#内容营销：打造持续输出的传播引擎&quot; class=&quot;headerlink&quot; title=&quot;内容营销：打造持续输出的传播引擎&quot;&gt;&lt;/a&gt;内容营销：打造持续输出的传播引擎&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;(OkCupid网站) 在“内容为王”的眼球经济时代，争夺用户有限注意力的有效方法之一就是持续输出内容，依靠内容来渗透和维系，从而获得潜在用户的认可关注。一篇爆红网络的帖子、一段让人泪流满面的视频、一组被千万人疯转的图片，虽然创作成本不高，却能启动持续传播的引擎，有些甚至经久不衰。这就是所谓的“内容营销”，也是获取新增用户屡试不爽的长效手段。&lt;br&gt;根据美国内容营销协会（Content Marketing Institute）的定义，内容营销是“一种通过生产发布有价值的、与目标人群有关联的、持续性的内容来吸引目标人群，改变或强化目标人群的行为，以产生商业转化为目的的营销方式。”用有价值的、持续且相关的内容来满足用户需求或扫除烦恼，不仅保证了内容自身的传播力，也有助于培养受众对品牌的信任度和忠诚度。产品通过为用户持续性地生产高质量的内容，才能在用户心中建立权威。&lt;br&gt;上面提到的OkCupid，就是一家善于制造内容来吸引用户的典型代表。从2009年创办伊始，创始人萨姆·亚根（Sam Yagan）就决心将自己与市场上现存的其他竞品（当时主要是Match.com和eHarmoney）区别开来。他采用的策略是通过内容营销的方式，来“影响那些有影响力的人”（Influence the Influencers）。&lt;br&gt;网络上，老套的“约会小贴士”早已铺天盖地。亚根深谙网民心理，他创建了官方博客OkTrends，长期创作和输出高质量、有趣且极具设计感的信息图表。在一篇名为《资料照片中的四大秘密》的帖子中，亚根用翔实的数据总结出露脸、微笑、女性胸部以上以及男性身着上衫的资料照片，更容易收获最佳的第一印象；在另一篇《你的长相与收件数量的关系》的文章里，作者以网友真实头像照片举例，揭示了一个血淋淋的真理：那些面容姣好的女性通常能获得5倍于普通面容女性、28倍于中下面容女性的收件数量；而最为热门的一篇《美貌中的数学》，则更是拿知名女星开涮，用数据聚落图煞有介事地向网民揭示自己的长相在大众审美中属于哪一派，以及怎样通过调整自拍角度来赢取更高的平均分。这些极具阅读性、娱乐性和传播性的博文，每一篇都成为了广为流传的“爆款”，甚至漂洋过海被翻译成了中文在微信朋友圈里大肆散播。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;产品上找到一个点和市场紧密配合&quot;&gt;&lt;a href=&quot;#产品上找到一个点和市场紧密配合&quot; class=&quot;headerlink&quot; title=&quot;产品上找到一个点和市场紧密配合&quot;&gt;&lt;/a&gt;产品上找到一个点和市场紧密配合&lt;/h2&gt;&lt;p&gt;往往一想到市场，感觉做的事情就是，送钱、转发、抽奖，可是在嘀嘀、快的、饿了么、美团、支付宝这些土豪狂轰滥炸之下，搞的小公司送钱送奖品完全拿不出手，扔进去激不起任何波澜。所以要另辟蹊径，做点动脑子的事情，举两个我觉得特别值得借鉴的例子吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、某医生类应用，任务中心、礼品中心做的非常有意思，你注册了医生之后，会通过各种办法激励你来邀请同医院 / 科室的同事、医学院的校友，帮你定制水晶名片、送你暖心鞋子（实际淘宝上 20 可以买到，可以标 100 多)、ceo 手写的信、专属定制封面的笔记本，免费手机流量，种种 “高大上” 且实用的东西，让医生忍不住参加，同时拿到东西后晒到朋友圈、微博，继续带来流量和曝光。获取医生的速度非常快，成本也能控制。&lt;/li&gt;
&lt;li&gt;2、图片社交一直不断有人尝试，很多应用风光一阵然后陨落，nice 却突飞猛进，气势如虹，同样的标签功能，为啥 nice 就大红大紫，备受用户喜爱，因为戳中了人们晒朋友圈第一痛点 “高逼格”，哪怕是穿着优衣库的上衣、H&amp;amp;M 的裤子、凡客帆布鞋这种搭配，都要在图片上把品牌标签戳出来，晒一晒，证明自己品位很年轻。当然了，能看到更多的用户给奢侈品上打标签，因为大部分中国戴奢饰品的很大痛点是别人不认识这个品牌，或是觉得一看就是假的^^，每张晒出来的照片只漏出来很小的一个 “nice” 的水印，但是瞬间，nice 获得了大量用户，套用经纬王华东的一句话，nice+ 微店已经成为移动电商标配产品和概念！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;做好客服，尤其抓住关键人物&quot;&gt;&lt;a href=&quot;#做好客服，尤其抓住关键人物&quot; class=&quot;headerlink&quot; title=&quot;做好客服，尤其抓住关键人物&quot;&gt;&lt;/a&gt;做好客服，尤其抓住关键人物&lt;/h2&gt;&lt;p&gt;这点真的非常重要，很实在，很多创始人喜欢去参加行业论坛做各种分享，做 panel talk 的嘉宾，觉得面子倍儿足。我个人觉得不如把这些时间花在和用户沟通上。&lt;/p&gt;
&lt;p&gt;有几个指标来判断创始人是否在乎用户&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、微信里是否有 200 个以上用户？看看他们的朋友圈，看看他们的生活状态&lt;/li&gt;
&lt;li&gt;2、每周是否和超过 20 个用户有过联系？&lt;/li&gt;
&lt;li&gt;3、每周能否请 3 个用户吃饭？&lt;/li&gt;
&lt;li&gt;4、每周能否解决 5 个用户反馈的问题？各种产品疑问、bug 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果能够有一个机制让团队和用户打成一片，对公司的意义会很大！之前听说大姨吗的柴可为了体验用户感受，自己带着卫生巾上班，是个很让人敬佩的举动。小米奉行的让工程师每天都在论坛里泡 1 个小时的规则，将开发人员和用户拉到一起，大大促进了生产力、提升了员工对业务的认可度、凝聚力也变强了！&lt;/p&gt;
&lt;h2 id=&quot;非公开市场-niche-渠道&quot;&gt;&lt;a href=&quot;#非公开市场-niche-渠道&quot; class=&quot;headerlink&quot; title=&quot;非公开市场 /niche 渠道&quot;&gt;&lt;/a&gt;非公开市场 /niche 渠道&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;今夜酒店特价&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当时我们抓住了最牛逼的华人色情社区——草榴，13年 的时候，草榴每天 300 万 UV，4000 万 PV。当时基本所有做酒店的都打 “约炮订酒店” 的点，“今夜” 也不例外，看草榴的基本都是男生，社区里核心的帖子就是晒约炮贴，背景全是酒店，精品贴的浏览量至少几十万，免费给如家、7 天、锦江打了大量免费广告。我们想如果贴子里如果能提到是用” 今夜酒店特价 “开的房，效果可能不错。然后费尽九牛二虎之力，摸索出一套在草榴里推广的方式，找到了一帮约炮发帖达人，送他们优惠券，他们写的贴子里都会加一句，是通过 “今夜” 定的房间，很便宜，顶峰时期，10 篇精华帖，6 篇都是我们的软文。累计不过花了 5000 元吧，带来了多少用户呢？10 万~几分钱一个用户，效果喜人，接着我们想尽办法获得了一批珍贵的草榴邀请码，做了 “草榴订酒店” 的 App，不过可惜没有通过市场审核，后来听说不少投资人都找天卓、Mars 要码，俨然把草榴邀请码当成了见面礼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;女性美容社区—美丽神器 App&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;初期推广的时候，绞尽脑汁，各种办法都尝试了，借郭美美整容炒作过、创始人吃饭看到美女就发名片介绍 App、各类女性社区发广告、甚至差点花钱做电梯广告！不过总算功夫不负有心人，他们找到了非常适合他们的人群：在夜总会工作的女生，据不完全统计，上海有 10 万女生在夜总会工作，她们很爱美丽，收入也比较高，随便消费点美白针、玻尿酸等微整形问题不大。他们通过各种办法，摸清了上海夜总会圈子的情况、用尽资源，进入了这些女生的白人微信群，给他们送福利，做活动，接受度很快，获取了上万的用户，而且非常的精准，到线下整形机构消费的转化率很高。后来就顺利的拿到融资，有了钱之后，开始规模化的投钱在微博粉丝通、微信大号上了、各类应用市场做活动，规模很快起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;获取用户是一件非常重要的事情，没有用户，产品就基本废了。其实，现实有很多意想不到的获取用户的案例。如果你身边有非常不错获取用户的案例，欢迎发过来，分享给更多的人学习。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/edagarli/howto-get-users&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/edagarli/howto-get-users&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;contact-me&quot;&gt;&lt;a href=&quot;#contact-me&quot; class=&quot;headerlink&quot; title=&quot;contact me&quot;&gt;&lt;/a&gt;contact me&lt;/h2&gt;&lt;p&gt;Weibo: &lt;a href=&quot;http://weibo.com/edagarli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@edagarli&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“在现代商业世界里，当一个才华横溢的创造者是没用的，除非你能同时把你创造的东西推销出去。”&lt;br&gt;——大卫·奥格威&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到种子投资的创业公司，第一个挑战就是把产品做出来，不少产品并未问世就夭折了，或者找外包公司做的 bug 满天飞的产品，能组一个靠谱的团队，把产品按照自己想象开发出来，实属不易。当这个挑战跨过去之后，就要开始找用户，不管用什么办法必须拿到 10 万用户，然后才有机会有下一轮融资，否则基本就拜拜了，至少有 80%的公司没有走过这一道坎。&lt;/p&gt;
&lt;p&gt;初创公司当产品初步完成后，就要开始找用户。当然，行业人脉和媒体关系极好，产品上线，立即吸引媒体纷纷专注并报道，或者融资能力极强，有足够多的钱可以做推广，这样的公司相对获取用户就更容易些。&lt;/p&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.edagarli.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="创业" scheme="http://blog.edagarli.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>每天都实战一个React-Native项目</title>
    <link href="http://blog.edagarli.com/2016/03/22/A%20self-taught%20project%20to%20learn%20React-Native/"/>
    <id>http://blog.edagarli.com/2016/03/22/A self-taught project to learn React-Native/</id>
    <published>2016-03-22T09:23:34.000Z</published>
    <updated>2016-03-22T09:23:34.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;A self-taught project to learn React-Native, I made a decision to put my every single day to write React-Native(Day and Day).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Project-Index&quot;&gt;&lt;a href=&quot;#Project-Index&quot; class=&quot;headerlink&quot; title=&quot;Project Index&quot;&gt;&lt;/a&gt;Project Index&lt;/h2&gt;&lt;p&gt;Day 01 - HelloWorld&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay/tree/master/Day01HelloWorld&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 01: Hello React-Native&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Day 02 - BasicExercises&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay/tree/master/Day02BasicExercises&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 02: BasicExercises&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Day 03 - Day03LayoutExercises&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay/tree/master/Day03LayoutExercises&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 03-1: Day03LayoutExercises&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay/tree/master/Day03LayoutExercisesTwo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 03-2: Day03LayoutExercisesTwo&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Day 04 - WriteModule&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay/tree/master/Day04WriteModule&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 04: WriteModule&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Day 05 - AppExercises&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/edagarli/React-Douban/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 05: React-Douban&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/douban.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Day 06 - ListViewLoadMore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay/tree/master/Day06ListViewLoadMore&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 06: Day06ListViewLoadMore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/day06.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Day 07 - RefreshableListView&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay/tree/master/Day07RefreshableListView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Project 07: Day07RefreshableListView&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/day07.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;What’s-next&quot;&gt;&lt;a href=&quot;#What’s-next&quot; class=&quot;headerlink&quot; title=&quot;What’s next?&quot;&gt;&lt;/a&gt;What’s next?&lt;/h2&gt;&lt;p&gt;Picture App&lt;/p&gt;
&lt;h2 id=&quot;License&quot;&gt;&lt;a href=&quot;#License&quot; class=&quot;headerlink&quot; title=&quot;License&quot;&gt;&lt;/a&gt;License&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/edagarli/ReactNativeDayAndDay&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Day And Day&lt;/a&gt; is under the MIT license.&lt;/p&gt;
&lt;h2 id=&quot;contact-me&quot;&gt;&lt;a href=&quot;#contact-me&quot; class=&quot;headerlink&quot; title=&quot;contact me&quot;&gt;&lt;/a&gt;contact me&lt;/h2&gt;&lt;p&gt;Weibo: &lt;a href=&quot;http://weibo.com/edagarli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@edagarli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter &lt;a href=&quot;http://twitter.com/edagarli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@edagarli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Telegram: @edagarli&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A self-taught project to learn React-Native, I made a decision to put my every single day to write React-Native(Day and Day).&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实践" scheme="http://blog.edagarli.com/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="React-Native" scheme="http://blog.edagarli.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>React-Native写了个DoubanApp</title>
    <link href="http://blog.edagarli.com/2016/03/17/React-Native%E5%86%99%E4%BA%86%E4%B8%AADoubanApp/"/>
    <id>http://blog.edagarli.com/2016/03/17/React-Native写了个DoubanApp/</id>
    <published>2016-03-17T14:48:00.000Z</published>
    <updated>2016-03-19T11:34:56.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;最近在学React，用React-Native写了个简单的小东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于 React-Native &amp;amp; 豆瓣Open API&lt;br&gt;(&lt;a href=&quot;https://github.com/edagarli/React-Douban&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/edagarli/React-Douban&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/douban.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在学React，用React-Native写了个简单的小东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于 React-Native &amp;amp; 豆瓣Open API&lt;br&gt;(&lt;a href=&quot;https://github.com/edagarli/React-Douban&quot;&gt;https://github.com/edagarli/React-Douban&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/douban.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实践" scheme="http://blog.edagarli.com/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="React-Native" scheme="http://blog.edagarli.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>switch与if-else效率问题</title>
    <link href="http://blog.edagarli.com/2016/03/09/switch%E4%B8%8Eif-else%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.edagarli.com/2016/03/09/switch与if-else效率问题/</id>
    <published>2016-03-09T03:21:00.000Z</published>
    <updated>2016-03-19T07:41:10.000Z</updated>
    
    <content type="html">&lt;p&gt;最近看见项目里面很多if-else，突然想到switch与if-else效率问题。&lt;br&gt;网上查了下资料，备记下：&lt;/p&gt;
&lt;p&gt;switch和if-else相比，由于使用了Binary Tree算法，绝大部分情况下switch会快一点，除非是if-else的第一个条件就为true.说实话  我也没有深入研究过这个问题的根源只是在实际开发中  没有人会去用很多很多else if的都是用 switch case 的  后者比较清晰  给人感觉就是一个脑子很清楚的人写出来的东西至于效率的本质  就让大企鹅去操心吧&lt;br&gt;编译器编译switch与编译if…else…不同。不管有多少case，都直接跳转，不需逐个比较查询。&lt;br&gt;昨天发现了一本叫做CSAPP的书，终于找到了关于switch问题的解答。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这是一段C代码：&lt;br&gt;/&lt;em&gt; $begin switch-c &lt;/em&gt;/&lt;br&gt;int switch_eg(int x)&lt;br&gt;{&lt;br&gt;    int result = x;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (x) {

case 100:
result *= 13;
break;

case 102:
result += 10;
/* Fall through */

case 103:
result += 11;
break;

case 104:
case 106:
result *= result;
break;

default:
result = 0;       
}

return result;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;/&lt;em&gt; $end switch-c &lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;用GCC汇编出来的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    .file    &amp;quot;switch.c&amp;quot;
    .version    &amp;quot;01.01&amp;quot;
gcc2_compiled.:
.text
    .align 4
.globl switch_eg
    .type     switch_eg,@function
switch_eg:
    pushl %ebp
    movl %esp,%ebp
    movl 8(%ebp),%edx
    leal -100(%edx),%eax
    cmpl ,%eax
    ja .L9
    jmp *.L10(,%eax,4)
    .p2align 4,,7
.section    .rodata
    .align 4
    .align 4
.L10:
    .long .L4
    .long .L9
    .long .L5
    .long .L6
    .long .L8
    .long .L9
    .long .L8
.text
    .p2align 4,,7
.L4:
    leal (%edx,%edx,2),%eax
    leal (%edx,%eax,4),%edx
    jmp .L3
    .p2align 4,,7
.L5:
    addl ,%edx
.L6:
    addl ,%edx
    jmp .L3
    .p2align 4,,7
.L8:
    imull %edx,%edx
    jmp .L3
    .p2align 4,,7
.L9:
    xorl %edx,%edx
.L3:
    movl %edx,%eax
    movl %ebp,%esp
    popl %ebp
    ret
.Lfe1:
    .size     switch_eg,.Lfe1-switch_eg
    .ident    &amp;quot;GCC: (GNU) 2.95.3 20010315 (release)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面的汇编代码中我们可以很清楚的看到switch部分被分配了一个连续的查找表，switch case中不连续的部分也被添加上了相应的条目，switch表的大小不是根据case语句的多少，而是case的最大值的最小值之间的间距。在选择相应 的分支时，会先有一个cmp子句，如果大于查找表的最大值，则跳转到default子句。而其他所有的case语句的耗时都回事O(1)。&lt;/p&gt;
&lt;p&gt;相比于if-else结构，switch的效率绝对是要高很多的，但是switch使用查找表的方式决定了case的条件必须是一个连续的常量。而if-else则可以灵活的多。&lt;/p&gt;
&lt;p&gt;可以看到if-else只是单纯地一个接一个比较，效率比较低&lt;br&gt;可以看出，switch的效率一般比if-else高&lt;br&gt;switch   效率高,     从汇编代码可以看出来&lt;br&gt;switch   只计算一次值   然后都是test   ,   jmp,&lt;br&gt;if…else   是每个条件都要计算一遍的.&lt;br&gt;switch的效率与分支数无关&lt;br&gt;当只有分支比较少的时候，if效率比switch高（因为switch有跳转表）&lt;br&gt;分支比较多，那当然是switch&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近看见项目里面很多if-else，突然想到switch与if-else效率问题。&lt;br&gt;网上查了下资料，备记下：&lt;/p&gt;
&lt;p&gt;switch和if-else相比，由于使用了Binary Tree算法，绝大部分情况下switch会快一点，除非是if-else的第一个条件就为true.说实话  我也没有深入研究过这个问题的根源只是在实际开发中  没有人会去用很多很多else if的都是用 switch case 的  后者比较清晰  给人感觉就是一个脑子很清楚的人写出来的东西至于效率的本质  就让大企鹅去操心吧&lt;br&gt;编译器编译switch与编译if…else…不同。不管有多少case，都直接跳转，不需逐个比较查询。&lt;br&gt;昨天发现了一本叫做CSAPP的书，终于找到了关于switch问题的解答。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.edagarli.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="java" scheme="http://blog.edagarli.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>如何解决消息发送一致性</title>
    <link href="http://blog.edagarli.com/2016/03/07/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://blog.edagarli.com/2016/03/07/如何解决消息发送一致性/</id>
    <published>2016-03-07T14:42:00.000Z</published>
    <updated>2016-03-19T07:42:22.000Z</updated>
    
    <content type="html">&lt;p&gt;消息发送一致性是什么？&lt;/p&gt;
&lt;p&gt;是指产生消息的业务动作与消息发送的一致，就是说，如果业务操作成功了，那么对应的消息一定要发送出去，否则就丢失消息了。而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;消息发送一致性很难保证吗？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void test(){
  //业务操作
  //列如写数据库，调用服务等
  //发送消息
}

void test(){
  // 发送消息
  //业务操作
  //列如写数据库，调用服务等
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面伪代码不管哪一步出现问题了，都很难保持一致性。虽然在实践中，第一种丢失消息的比例相对第二种是很低的。但是，要求保证一致性的场景，上面的两种方案都不能接受。&lt;/p&gt;
&lt;p&gt;使用JMS可以实现消息一致性吗？&lt;/p&gt;
&lt;p&gt;用过JMS的都知道，JMS的API种，有很多XA开头的接口。其实如果不实用XA系列的接口实现，那么我们就无法直接得到发送消息给消息中间件及业务操作这两个事情的事物保证，而JMS中定义的XA系列的接口就是为了实现分布式事务的支持（发送消息和业务操作很难做在一个本地事务中）。但是会有如下问题:&lt;/p&gt;
&lt;p&gt;1.引入了分布式事务，这会带来一些开销并增加复杂性。&lt;br&gt;2.对于业务操作有限制，要求业务操作的资源必须支持XA协议，才能够与发送消息一起来做分布式事务。这会成为一个限制，因为并不是所有需要与发送消息一起做成分布式事务的业务操作都支持XA协议。&lt;/p&gt;
&lt;p&gt;其他的办法？&lt;/p&gt;
&lt;p&gt;JMS可以解决一致性问题，但是存在一些限制并且成本相对较高。那么有没有其他的办法呢？如图所示方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可能这个过程当中会出现很多异常，下面具体分析下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-10.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么如何了解业务操作的结果呢？&lt;/p&gt;
&lt;p&gt;下面展示了这个过程。由消息中间件主动询问业务应用，获取待处理消息所对的业务操作的结果，然后业务应用需要对业务操作结果进行检查，并且把结果发送给消息中间件，然后根据这个结果，更新状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/3.0/cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知识共享署名-相同方式共享 3.0 中国大陆许可协议&lt;/a&gt;，转载、引用前需联系作者，并署名作者且注明文章出处 。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;消息发送一致性是什么？&lt;/p&gt;
&lt;p&gt;是指产生消息的业务动作与消息发送的一致，就是说，如果业务操作成功了，那么对应的消息一定要发送出去，否则就丢失消息了。而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去。&lt;/p&gt;
    
    </summary>
    
      <category term="聊聊架构" scheme="http://blog.edagarli.com/categories/%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term=" 消息中间件" scheme="http://blog.edagarli.com/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>60多年前，一群小白程序员扒了一个俄罗斯的开源框架</title>
    <link href="http://blog.edagarli.com/2016/03/06/%E4%B8%80%E7%BE%A4%E5%B0%8F%E7%99%BD%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%92%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%84%E7%BD%97%E6%96%AF%E7%9A%84%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    <id>http://blog.edagarli.com/2016/03/06/一群小白程序员扒了一个俄罗斯的开源框架/</id>
    <published>2016-03-06T04:06:00.000Z</published>
    <updated>2016-03-19T07:41:21.000Z</updated>
    
    <content type="html">&lt;p&gt;60多年前，一群小白程序员扒了一个俄罗斯的开源框架，写了几行漏洞百出的代码，产品上线运营了，30年后新的CTO实在看不下去了，重构了部分代码，但框架依旧是旧的，又过了30年新代码和就框架严重不兼容，产品濒临崩溃，用户流失严重，这时我们该&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1继续修bug打补丁&lt;/p&gt;
&lt;p&gt;2换个框架重构代码&lt;/p&gt;
&lt;p&gt;3干脆换掉这些程序猿。&lt;/p&gt;
&lt;p&gt;关键是那个开源框架糟烂得很，还没哪个使用它的产品成功过，后来连俄国人自己都抛弃不用了Communix操作系统最早是两个德国人Marx和Engles开发的（称为Communix基础版，或Communix 1.0和2.0），遵守GPL，它的早期支持者曾经先后组织过两个国际讨论区。&lt;/p&gt;
&lt;p&gt;当时少数先进的国家都使用最早由英国人开发后来在美国得到大力发展的Libertix，亚洲、非洲和澳洲人当时本土更古老的操作系统已经或濒于崩溃，多数成为受Libertix主机控制的远程终端。相比之下， Communix支持的机子很少，但移植Communix的努力一直就没停止过。最早是以法国为主的一些人在巴黎、里昂等地移植过，但失败了。&lt;/p&gt;
&lt;p&gt;此后Communix分成两条路发展，一条是删除一些不兼容的代码，把Communix移植到Libertix上运行；另一批人在俄国著名程序员 Lenin的领导下，在俄国移植Communix获得成功（第一次发行时称为俄版Communix beta或Communix 3.0 beta），俄版Communix一度做到15个主节点、20多个子节点的大规模并行Cluster，并影响到亚洲、东欧、拉美等一些地方。&lt;/p&gt;
&lt;p&gt;在Lenin之后，俄版Communix项目的两个CEO对Communix 3.0正式版出现了意见分歧。势力强大的Stalin重视系统安全和运行效率，认为需要在已有的基础上继续优化俄版Communix代码；实力较弱小的Trotsky认为Communix必须支持更多的硬件，提供更多的功能。这次分歧以Trotsky失败告终。&lt;/p&gt;
&lt;p&gt;Trotsky和他的团队后来开发了自己的Communix（称为托版Communix或Communix 4.0），但除了在斯里兰卡短暂地装过一段时间以外，都是小用户，这些用户又加入了很多自己的东西，且互相不统一，Trotsky死后没人整理，因此托版Communix非常乱。&lt;/p&gt;
&lt;p&gt;而由Stalin的团队打造的Communix 3.0正式版因为过于注重系统安全和效率，导致接口不够友好，娱乐功能少，不能及时更新一些新功能。Stalin的继任者由一个极端走向另一个极端，他们片面追求漂亮接口和娱乐功能，甚至干脆向欧美的Libertix购买这些功能，放弃了系统安全和效率，更不对代码作任何优化，导致系统经常当机和被黑客入侵，最后不得不改装Libertix。&lt;/p&gt;
&lt;p&gt;在俄国成功移植Communix的消息也鼓舞着中国的Communix爱好者们，但早期的努力都不成功。一个姓毛的人说，俄版Communix光是汉化还不行，因为我们的硬件配置太低，短期内也不可能更新，所以必须为我们自己的硬件改写一部分底层代码。&lt;/p&gt;
&lt;p&gt;这种办法最后成功了，毛版Communix一度曾成为低配置计算机移植Communix的经典范例。毛还反对俄版Communix晚期的一些修改，认为这是向Libertix投降。为了及时清理Communix队伍内部的Libertix代理人，他发动广大用户学Communix和写 Communix，打造一个“六亿神州皆Hacker”的毛版Communix。他的主张遭到开发团队的反对，最后无果而终，但影响持续至今。&lt;/p&gt;
&lt;p&gt;如今，一个精通毛版Communix的程序员往往被看作是危险的黑客，而那些拿了很多认证的Communix程序员都在跟Libertix学接轨。也有人认为，所谓的“毛版Communix”其实是用户的误解，毛在中国发布的操作系统的正确名称是Maox OS，这个系统仅仅只是借鉴了Communix的目录结构等标准，与Communix并无代码上的继承关系，只能称之为“Communix Like”系统。&lt;/p&gt;
&lt;p&gt;到70年代后期，毛版Communix由于缺乏对于新硬件和新技术的支持，同时本身的大量漏洞也暴露无遗，已经变得很不稳定，此时一个中国Communix开源小区的程序员Deng更改了一部分Communix的内核，采用了微内核技术，这个改进最初在一定程度上解决了原版Communix对内存调用存在的内存泄露和内存管理效率低下的问题，同时提高了磁盘操作效率，并且比较成功地解决了许多应用程序在Communix与世界主流使用的Libertix的兼容问题。&lt;/p&gt;
&lt;p&gt;邓版Communix本来试图引进一些Libertix系统的部分特点，但由于考虑不周，设计上有不少漏洞，更由于Communix本身固有的弊病和程序员Deng及其后继者无心也无力从根本上对Communix的内核进行更新，导致邓版Communix运行30年后出现少数进程劫持了系统核心并占用了大量资源的情况，系统的稳定性和安全性看来已出现了严重的问题。&lt;/p&gt;
&lt;p&gt;当今世界，除中国仍在使用Communix外，还有朝鲜、古巴、越南等少数国家也在使用Communix。&lt;/p&gt;
&lt;p&gt;朝鲜的金版Communix系统是毛版Communix系统mini版，又称毛版Communix系统朝鲜语版。&lt;/p&gt;
&lt;p&gt;由于朝鲜的硬件配置仍然较低，适应低硬件配置的毛版Communix系统朝鲜语版运行仍然比较流畅。&lt;/p&gt;
&lt;p&gt;古巴的Castro版Communix系统类似于金版Communix系统，而越南人使用的胡版Communix近年来经改良后则更像中国的邓版Communix。&lt;/p&gt;
&lt;p&gt;此外，尼泊尔有部分人宣称他们要在尼泊尔安装毛版Communix系统，但又有人说尼泊尔人的毛版Communix是“山寨版”的Communix。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果觉得有点用处，可以请我喝杯咖啡!&lt;br&gt;&lt;img src=&quot;/images/aex068188cqwy9xbxa3oc07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;60多年前，一群小白程序员扒了一个俄罗斯的开源框架，写了几行漏洞百出的代码，产品上线运营了，30年后新的CTO实在看不下去了，重构了部分代码，但框架依旧是旧的，又过了30年新代码和就框架严重不兼容，产品濒临崩溃，用户流失严重，这时我们该&lt;/p&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.edagarli.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="查水表" scheme="http://blog.edagarli.com/tags/%E6%9F%A5%E6%B0%B4%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>大浏览量系统的解决思路</title>
    <link href="http://blog.edagarli.com/2016/03/02/%E5%A4%A7%E6%B5%8F%E8%A7%88%E9%87%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
    <id>http://blog.edagarli.com/2016/03/02/大浏览量系统的解决思路/</id>
    <published>2016-03-02T15:07:00.000Z</published>
    <updated>2016-03-19T07:42:03.000Z</updated>
    
    <content type="html">&lt;p&gt;随着网站的发展壮大，系统也面临越来越多的挑战，有些是业务发展带来的挑战，例如大型促销活动，秒杀活动等突发流量冲击；还有一些是非正常的访问请求，例如网站经常受到攻击和恶意请求。像这种流量突然暴增的情况对系统的冲击很大，有时候流量突然暴增的情况对系统的冲击很大，有时候流量瞬间可达到20w/s的QPS,所以如何让系统有更好的性能和稳定性是我们面临的一大挑战。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在介绍前台系统的静态化改造之前，先说说可以做哪些优化工作。介绍下淘宝前台系统的优化历程。&lt;/p&gt;
&lt;p&gt;2009年，系统拆分，静态文件合并，前端页面异步化和JSON化。&lt;br&gt;2010年，去DB依赖，引入缓存，提升单机QPS，关注用户体验。&lt;br&gt;2011年，优化进入深水区Velocity，BigPipe。&lt;br&gt;2012年，静态化改造。&lt;br&gt;2013年，统一Cache，CDN化，网络协议。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;静态改造&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;1.什么是静态化系统&lt;/p&gt;
&lt;p&gt;在要改造成静态化系统之前首先要搞明白什么是静态化系统？&lt;/p&gt;
&lt;p&gt;几个特征：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.一个页面对应URL通常固定。
2.在页面中不能包含与浏览者相关的因素，这里所说的“不能包含”不包括JS动态生成的部分，也就是在页面中HTML代码不能明显地含有与浏览器相关的DOM。
3.在页面中不包含时间因素。页面同样不能含有与时间（而是服务端输出的时间）相关的因素，页面中的DOM不随时间变化而变化。
4.页面中不包含地域信息。
5.不能包含Cookie等私有数据。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么要进行静态化架构设计&lt;/p&gt;
&lt;p&gt;系统经过多次优化升级，包括系统架构的升级，系统本身的模块优化，代码优化和增加各种缓存等这些优化，我们的优化层次都是在java系统中做改进的。在这种情况下压测我们的java系统，性能依旧不能满足我们的期望，我们的目标是再上一个数量级。&lt;/p&gt;
&lt;p&gt;如何改造动态系统&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;URL唯一化
分离与浏览者相关的因素。
分离时间因素。
异地化地域因素。
去掉Cookie。
   动态内容结构化。（ESI和CSI）
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;随着网站的发展壮大，系统也面临越来越多的挑战，有些是业务发展带来的挑战，例如大型促销活动，秒杀活动等突发流量冲击；还有一些是非正常的访问请求，例如网站经常受到攻击和恶意请求。像这种流量突然暴增的情况对系统的冲击很大，有时候流量突然暴增的情况对系统的冲击很大，有时候流量瞬间可达到20w/s的QPS,所以如何让系统有更好的性能和稳定性是我们面临的一大挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="案例" scheme="http://blog.edagarli.com/categories/%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="案例" scheme="http://blog.edagarli.com/tags/%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能调优</title>
    <link href="http://blog.edagarli.com/2016/03/01/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://blog.edagarli.com/2016/03/01/JVM性能调优/</id>
    <published>2016-03-01T03:24:00.000Z</published>
    <updated>2016-03-19T07:40:11.000Z</updated>
    
    <content type="html">&lt;p&gt;最近线上问题很多，本来想写篇JVM性能调优，但发现@优雅先生 已经写了篇很不错的文章，所以不打算再写了，等下次有时间再分享一篇线上问题案例分析。文章如下,花了点时间，排了下版。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;b&gt;JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JDK本身提供了很多方便的JVM性能调优监控工具，除了集成式的VisualVM和jConsole外，还有jps、jstack、jmap、jhat、jstat、hprof等小巧的工具，本博客希望能起抛砖引玉之用，让大家能开始对JVM性能调优的常用工具有所了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现实企业级Java开发中，有时候我们会碰到下面这些问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OutOfMemoryError，内存不足

内存泄露

线程死锁

锁争用（Lock Contention）

Java进程消耗CPU过高

......
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些问题在日常开发中可能被很多人忽视（比如有的人遇到上面的问题只是重启服务器或者调大内存，而不会深究问题根源），但能够理解并解决这些问题是Java程序员进阶的必备要求。本文将对一些常用的JVM性能调优监控工具进行介绍，希望能起抛砖引玉之用。本文参考了网上很多资料，难以一一列举，在此对这些资料的作者表示感谢！关于JVM性能调优相关的资料，请参考文末。&lt;/p&gt;
&lt;p&gt;A、 jps(Java Virtual Machine Process Status Tool)      &lt;/p&gt;
&lt;p&gt;jps主要用来输出JVM中运行的进程状态信息。语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jps [options] [hostid]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不指定hostid就默认为当前主机或服务器。&lt;/p&gt;
&lt;p&gt;命令行参数选项说明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-q 不输出类名、Jar名和传入main方法的参数
-m 输出传入main方法的参数
-l 输出main类或Jar的全限名
-v 输出传入JVM的参数

root@ubuntu:/# jps -m -l
2458 org.artifactory.standalone.main.Main     /usr/local/artifactory-2.2.5/etc/jetty.xml
29920 com.sun.tools.hat.Main -port 9998 /tmp/dump.dat
3149 org.apache.catalina.startup.Bootstrap start
30972 sun.tools.jps.Jps -m -l
8247 org.apache.catalina.startup.Bootstrap start
25687 com.sun.tools.hat.Main -port 9999 dump.dat
21711 mrf-center.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;B、 jstack&lt;/p&gt;
&lt;p&gt;jstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jstack [option] pid
jstack [option] executable core
jstack [option] [server-id@]remote-hostname-or-ip
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令行参数选项说明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况
-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。&lt;/p&gt;
&lt;p&gt;第一步先找出Java进程ID，我部署在服务器上的Java应用名称为mrf-center：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu:/# ps -ef | grep mrf-center | grep -v grep
root     21711     1  1 14:47 pts/3    00:02:10 java -jar mrf-center.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;得到进程ID为21711，第二步找出该进程内最耗费CPU的线程，可以使用ps -Lfp pid或者ps -mp pid -o THREAD, tid, time或者top -Hp pid，我这里用第三个，输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-3.png&quot; alt=&quot;pasted image&quot;&gt;&lt;/p&gt;
&lt;p&gt;TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为21742的线程，用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf &amp;quot;%x\n&amp;quot; 21742
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;得到21742的十六进制值为54ee，下面会用到。&lt;br&gt;OK，下一步终于轮到jstack上场了，它用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu:/# jstack 21711 | grep 54ee
&amp;quot;PollIntervalRetrySchedulerThread&amp;quot; prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() [0x00007f94c6eda000]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()，我找了下我的代码，定位到下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Idle wait
getLog().info(&amp;quot;Thread [&amp;quot; + getName() + &amp;quot;] is idle waiting...&amp;quot;);
schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;
long now = System.currentTimeMillis();
long waitTime = now + getIdleWaitTime();
long timeUntilContinue = waitTime - now;
synchronized(sigLock) {
try {
if(!halted.get()) {
sigLock.wait(timeUntilContinue);
}
}
catch (InterruptedException ignore) {
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它是轮询任务的空闲等待代码，上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。&lt;/p&gt;
&lt;p&gt;C、 jmap（Memory Map）和jhat（Java Heap Analysis Tool）&lt;/p&gt;
&lt;p&gt;jmap用来查看堆内存使用状况，一般结合jhat使用。&lt;/p&gt;
&lt;p&gt;jmap语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jmap [option] pid
jmap [option] executable core
jmap [option] [server-id@]remote-hostname-or-ip
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果运行在64位JVM上，可能需要指定-J-d64命令选项参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jmap -permstat pid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息，如下图：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;/images/pasted-4.png&quot; alt=&quot;pasted image&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用jmap -heap pid查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。比如下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu:/# jmap -heap 21711
Attaching to process ID 21711, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 20.10-b01

using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
MinHeapFreeRatio = 40
MaxHeapFreeRatio = 70
MaxHeapSize      = 2067791872 (1972.0MB)
NewSize          = 1310720 (1.25MB)
MaxNewSize       = 17592186044415 MB
OldSize          = 5439488 (5.1875MB)
NewRatio         = 2
SurvivorRatio    = 8
PermSize         = 21757952 (20.75MB)
MaxPermSize      = 85983232 (82.0MB)

Heap Usage:
PS Young Generation
Eden Space:
capacity = 6422528 (6.125MB)
used     = 5445552 (5.1932830810546875MB)
free     = 976976 (0.9317169189453125MB)
84.78829520089286% used
From Space:
capacity = 131072 (0.125MB)
used     = 98304 (0.09375MB)
free     = 32768 (0.03125MB)
75.0% used
To Space:
capacity = 131072 (0.125MB)
used     = 0 (0.0MB)
free     = 131072 (0.125MB)
0.0% used
PS Old Generation
capacity = 35258368 (33.625MB)
used     = 4119544 (3.9287033081054688MB)
free     = 31138824 (29.69629669189453MB)
11.683876009235595% used
PS Perm Generation
capacity = 52428800 (50.0MB)
used     = 26075168 (24.867218017578125MB)
free     = 26353632 (25.132781982421875MB)
49.73443603515625% used
....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  root@ubuntu:/# jmap -histo:live 21711 | more

   num     #instances         #bytes  class name
 1:         38445        5597736  &amp;lt;constMethodKlass&amp;gt;
 2:         38445        5237288  &amp;lt;methodKlass&amp;gt;
 3:          3500        3749504  &amp;lt;constantPoolKlass&amp;gt;
 4:         60858        3242600  &amp;lt;symbolKlass&amp;gt;
 5:          3500        2715264  &amp;lt;instanceKlassKlass&amp;gt;
 6:          2796        2131424  &amp;lt;constantPoolCacheKlass&amp;gt;
 7:          5543        1317400  [I
 8:         13714        1010768  [C
 9:          4752        1003344  [B
10:          1225         639656  &amp;lt;methodDataKlass&amp;gt;
11:         14194         454208  java.lang.String
12:          3809         396136  java.lang.Class
13:          4979         311952  [S
14:          5598         287064  [[I
15:          3028         266464  java.lang.reflect.Method
16:           280         163520  &amp;lt;objArrayKlassKlass&amp;gt;
17:          4355         139360  java.util.HashMap$Entry
18:          1869         138568  [Ljava.util.HashMap$Entry;
19:          2443          97720  java.util.LinkedHashMap$Entry
20:          2072          82880  java.lang.ref.SoftReference
21:          1807          71528  [Ljava.lang.Object;
22:          2206          70592  java.lang.ref.WeakReference
23:           934          52304  java.util.LinkedHashMap
24:           871          48776  java.beans.MethodDescriptor
25:          1442          46144  java.util.concurrent.ConcurrentHashMap$HashEntry
26:           804          38592  java.util.HashMap
27:           948          37920  java.util.concurrent.ConcurrentHashMap$Segment
28:          1621          35696  [Ljava.lang.Class;
29:          1313          34880  [Ljava.lang.String;
30:          1396          33504  java.util.LinkedList$Entry
31:           462          33264  java.lang.reflect.Field
32:          1024          32768  java.util.Hashtable$Entry
33:           948          31440  [Ljava.util.concurrent.ConcurrentHashMap$HashEntry;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;class name是对象类型，说明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;B  byte
C  char
D  double
F  float
I  int
J  long
Z  boolean
[  数组，如[I表示int[]
[L+类名 其他对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有一个很常用的情况是：用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。jmap进行dump命令格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jmap -dump:format=b,file=dumpFileName pid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我一样地对上面进程ID为21711进行Dump：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu:/# jmap -dump:format=b,file=/tmp/dump.dat 21711     
Dumping heap to /tmp/dump.dat ...
Heap dump file created
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; dump出来的文件可以用MAT、VisualVM等工具查看，这里用jhat查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; root@ubuntu:/# jhat -port 9998 /tmp/dump.dat
Reading from /tmp/dump.dat...
Dump file created Tue Jan 28 17:46:14 CST 2014
Snapshot read, resolving...
Resolving 132207 objects...
Chasing references, expect 26 dots..........................
Eliminating duplicate references..........................
Snapshot resolved.
Started HTTP server on port 9998
Server is ready.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意如果Dump文件太大，可能需要加上-J-Xmx512m这种参数指定最大堆内存，即jhat -J-Xmx512m -port 9998 /tmp/dump.dat。然后就可以在浏览器中输入主机地址:9998查看了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-5.png&quot; alt=&quot;pasted image&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面红线框出来的部分大家可以自己去摸索下，最后一项支持OQL（对象查询语言）。&lt;/p&gt;
&lt;p&gt;D、jstat（JVM统计监测工具）&lt;/p&gt;
&lt;p&gt;语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。interval是采样时间间隔。count是采样数目。比如下面输出的是GC信息，采样时间间隔为250ms，采样数为4：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu:/# jstat -gc 21711 250 4
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649
192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649
192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649
192.0  192.0   64.0   0.0    6144.0   2109.7   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要明白上面各列的意义，先看JVM堆内存布局：&lt;/p&gt;
&lt;p&gt;可以看出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;堆内存 = 年轻代 + 年老代 + 永久代
年轻代 = Eden区 + 两个Survivor区（From和To）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在来解释各列含义：&lt;br&gt;          S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）&lt;br&gt;          EC、EU：Eden区容量和使用量&lt;br&gt;          OC、OU：年老代容量和使用量&lt;br&gt;          PC、PU：永久代容量和使用量&lt;br&gt;          YGC、YGT：年轻代GC次数和GC耗时&lt;br&gt;          FGC、FGCT：Full GC次数和Full GC耗时&lt;br&gt;          GCT：GC总耗时&lt;/p&gt;
&lt;p&gt;E、hprof（Heap/CPU Profiling Tool）&lt;/p&gt;
&lt;p&gt;hprof能够展现CPU使用率，统计堆内存使用情况。&lt;br&gt;语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -agentlib:hprof[=options] ToBeProfiledClass
java -Xrunprof[:options] ToBeProfiledClass
javac -J-agentlib:hprof[=options] ToBeProfiledClass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;完整的命令选项如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      Option Name and Value  Description                    Default
      ---------------------  -----------                    -------
      heap=dump|sites|all    heap profiling                 all
      cpu=samples|times|old  CPU usage                      off
      monitor=y|n            monitor contention             n
      format=a|b             text(txt) or binary output     a
      file=&amp;lt;file&amp;gt;            write data to file             java.hprof[.txt]
      net=&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;      send data over a socket        off
      depth=&amp;lt;size&amp;gt;           stack trace depth              4
      interval=&amp;lt;ms&amp;gt;          sample interval in ms          10
      cutoff=&amp;lt;value&amp;gt;         output cutoff point            0.0001
      lineno=y|n             line number in traces?         y
      thread=y|n             thread in traces?              n
      doe=y|n                dump on exit?                  y
      msa=y|n                Solaris micro state accounting n
      force=y|n              force output to &amp;lt;file&amp;gt;         y
      verbose=y|n            print messages about dumps     y
来几个官方指南上的实例。

CPU Usage Sampling Profiling(cpu=samples)的例子：
java -agentlib:hprof=cpu=samples,interval=20,depth=3     Hello
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，在当前目录。&lt;/p&gt;
&lt;p&gt;CPU Usage Times Profiling(cpu=times)的例子，它相对于CPU Usage Sampling Profile能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javac -J-agentlib:hprof=cpu=times Hello.java
Heap Allocation Profiling(heap=sites)的例子：

javac -J-agentlib:hprof=heap=sites Hello.java
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Heap Dump(heap=dump)的例子，它比上面的Heap Allocation Profiling能生成更详细的Heap Dump信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javac -J-agentlib:hprof=heap=dump Hello.java
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然在JVM启动参数中加入-Xrunprof:heap=sites参数可以生成CPU/Heap Profile文件，但对JVM性能影响非常大，不建议在线上服务器环境使用。&lt;/p&gt;
&lt;p&gt;其他JVM性能调优参考资料：&lt;/p&gt;
&lt;p&gt;《Java虚拟机规范》&lt;/p&gt;
&lt;p&gt;《Java Performance》&lt;/p&gt;
&lt;p&gt;《Trouble Shooting Guide for JavaSE 6 with HotSpot VM》: &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/tsg-vm-149989.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oracle.com/technetwork/java/javase/tsg-vm-149989.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《Effective Java》&lt;/p&gt;
&lt;p&gt;VisualVM: &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/visualvm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.oracle.com/javase/7/docs/technotes/guides/visualvm/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;jConsole: &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Monitoring and Managing JavaSE 6 Applications: &lt;a href=&quot;http://www.oracle.com/technetwork/articles/javase/monitoring-141801.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oracle.com/technetwork/articles/javase/monitoring-141801.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BTrace：&lt;a href=&quot;https://kenai.com/projects/btrace&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://kenai.com/projects/btrace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://my.oschina.net/feichexia/blog/196575&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://my.oschina.net/feichexia/blog/196575&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近线上问题很多，本来想写篇JVM性能调优，但发现@优雅先生 已经写了篇很不错的文章，所以不打算再写了，等下次有时间再分享一篇线上问题案例分析。文章如下,花了点时间，排了下版。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://blog.edagarli.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://blog.edagarli.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title> 发布或重启线上服务时load很高之解决方案</title>
    <link href="http://blog.edagarli.com/2016/03/01/%E5%8F%91%E5%B8%83%E6%88%96%E9%87%8D%E5%90%AF%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%97%B6%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.edagarli.com/2016/03/01/发布或重启线上服务时抖动问题解决方案/</id>
    <published>2016-03-01T02:45:00.000Z</published>
    <updated>2016-03-19T07:41:59.000Z</updated>
    
    <content type="html">&lt;p&gt;最近发现项目重启时，load会飙到非常高，然后运行了一段时间，会恢复正常，所以集中整理了下资料以便查阅。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LBSer/p/3703967.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/LBSer/p/3703967.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://confluence.atlassian.com/jirakb/jira-crashes-due-to-codecache-is-full-compiler-has-been-disabled-314447083.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://confluence.atlassian.com/jirakb/jira-crashes-due-to-codecache-is-full-compiler-has-been-disabled-314447083.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://qa.blog.163.com/blog/static/190147002201392221426372/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://qa.blog.163.com/blog/static/190147002201392221426372/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现项目重启时，load会飙到非常高，然后运行了一段时间，会恢复正常，所以集中整理了下资料以便查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="案例" scheme="http://blog.edagarli.com/categories/%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="服务器" scheme="http://blog.edagarli.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何不死掉</title>
    <link href="http://blog.edagarli.com/2016/02/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E6%AD%BB%E6%8E%89/"/>
    <id>http://blog.edagarli.com/2016/02/28/如何不死掉/</id>
    <published>2016-02-28T11:18:00.000Z</published>
    <updated>2016-03-19T07:42:17.000Z</updated>
    
    <content type="html">&lt;p&gt;今天失恋了，好难受。我发现这段时间经历的事情特别多，接连经历创业失败，撞车，失恋，彷佛生活差到了极点。&lt;/p&gt;
&lt;p&gt;每每遇到这样的事情，我都会消沉一天，然后重新振作，没什么大不了的。此时此刻，想起了我之前分享的一篇文章。&lt;/p&gt;
 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;b&gt;如何不死掉——How Not to Die&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;创业公司能活下去，靠的是不抛弃不放弃的士气。&lt;/p&gt;
&lt;p&gt;创业是个艰辛的过程，成功的创业者变得富有，失败的创业者一无所有（除了经验教训）。Paul Graham提到如果一个创业公司与Y Combinator失去联系，或者创业者不再出现在每周的聚会上，基本说明这个创业公司要挂掉了。（在国内，或许是下面的情景预示着公司即将挂掉：创业公司淡出人们的实现，创业者不再露面吧）。死掉的创业公司都是默默就挂掉了，悄无声息的就死了。&lt;/p&gt;
&lt;p&gt;定期参加创业者或者投资人的聚会，能迫使你每次都做出新东西。如果距离上次聚会你的产品没有任何变化，你真的都不好意思去。所以，让自己和自己的产品活在圈子里、灯光下，强迫自己和自己的团队迭代前进。&lt;/p&gt;
&lt;p&gt;大部分创业公司因为意志消沉而停滞不前。其实创业的过程就是起起落落，没有什么产品能够一帆风顺，即使是Google也有迷茫甚至是遇挫的时候。而创始人唯一能做的就是打气精神，继续迭代更新自己的产品，千万不能一蹶不振。&lt;/p&gt;
&lt;p&gt;在创业期间不要轻易去读研，因为一旦你选择去读书，创业就成了你的兼职，你会找各种借口推迟产品发布，导致失败。&lt;/p&gt;
&lt;p&gt;创业不死掉的秘诀：足够聪明，在一个有前途的领域做事，不放弃。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;生活也是这样，但要明白不放弃就对了。&lt;/p&gt;
&lt;p&gt;心累，晚安&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天失恋了，好难受。我发现这段时间经历的事情特别多，接连经历创业失败，撞车，失恋，彷佛生活差到了极点。&lt;/p&gt;
&lt;p&gt;每每遇到这样的事情，我都会消沉一天，然后重新振作，没什么大不了的。此时此刻，想起了我之前分享的一篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.edagarli.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="创业" scheme="http://blog.edagarli.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>为啥HBase需要搭建SQL引擎层</title>
    <link href="http://blog.edagarli.com/2016/02/12/%E4%B8%BA%E5%95%A5HBase%E9%9C%80%E8%A6%81%E6%90%AD%E5%BB%BASQL%E5%BC%95%E6%93%8E%E5%B1%82/"/>
    <id>http://blog.edagarli.com/2016/02/12/为啥HBase需要搭建SQL引擎层/</id>
    <published>2016-02-12T13:51:00.000Z</published>
    <updated>2016-03-19T07:41:25.000Z</updated>
    
    <content type="html">&lt;p&gt;现有的SQL解决方案通常都不是水平可伸缩的，因此当数据量变大时会遇到障碍。但是这样的情况，随着NoSQL的出现已经得到很大程度的缓解，并且随着NoSQL技术的完善与成熟，这种情况将会从根本上解决。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们知道NoSQL区别于关系型数据库的一点就是NoSQL不使用SQL作为查询语言，至于为何在NoSQL数据存储HBase上提供SQL接口，有如下原因：&lt;/p&gt;
&lt;p&gt;1.使用诸如SQL这样易于理解的语言，使人们能够更加轻松地使用HBase。&lt;/p&gt;
&lt;p&gt;2.使用诸如SQL这样更高层次的语言来编写，减少了编写的代码量。&lt;/p&gt;
&lt;p&gt;3.执行查询时，在数据访问与运行时执行之间加上SQL这样一层抽象可以进行大量优化。例如，对于GROUP BY查询来说，利用HBase中协同处理器，聚合可以在服务器上进行，而不必在客户端，这么做会极大减少客户端与服务器之间传输的数据量。此外，也可以在客户端并行执行GROUP BY，这是根据行健的范围来截断扫描而实现的。通过并行执行，结果会更快的返回。所有这些优化无需用户参与，只需执行查询即可。&lt;/p&gt;
&lt;b&gt;基于HBase的SQL引擎实现&lt;/b&gt;

&lt;p&gt;现阶段业内有一些关于HBase SQL引擎层的尝试，已经有一些比较稳定的解决方案和现实。&lt;/p&gt;
&lt;p&gt;1.Hive整合HBase&lt;/p&gt;
&lt;p&gt;Hive与HBase的整合功能从Hive0.6.0版本已经开始出现，利用两者对外的API接口互相通信，通信主要依靠hive_hbase-handler.jar工具包（Hive Storage Handlers）。由于HBase有一次比较大的版本变动，所以并不是每个版本的Hive都能和现有的HBase版本进行整合，所以在使用过程中特别注意的就是两者版本的一致性。&lt;/p&gt;
&lt;p&gt;2.Phoenix&lt;/p&gt;
&lt;p&gt;Phoenix由Salesforce.com开源，是构建在Apache HBase之上的一个SQL中间层，可以让开发者在HBase上执行SQL查询。Phoenix 完全使用Java编写，代码位于Github上，并且提供了一个客户端可嵌入的JDBC驱动。对于10w到100w行的简单查询来说，Phoenix要胜于Hive。&lt;/p&gt;
&lt;p&gt;3.Kundera&lt;/p&gt;
&lt;p&gt;Kundera 是一个JPA2.0兼容的NoSQL数据存储的对象映射框架。Kundera基于现有类库构建，封装出简易的API，其主要特性有：&lt;/p&gt;
&lt;p&gt;1）支持交叉数据存储持久性，这意味着用户可以在不同的数据存储使用单一方法存储和获取相关实体。&lt;br&gt;2)能够很好地管理事务，同时支持EntityTransaction和Java Transaction API（JPA）。&lt;br&gt;3) 兼容JPA2.0，严格使用JPA注释对象映射到数据存储表。&lt;br&gt;4) 目前支持的NoSQL服务器包括: HBase,MongoDB,Redis,Neo4j等。&lt;/p&gt;
&lt;p&gt;还有其它一些解决方案，例如：Lealone,hbase-sql,Impala等，要么不成熟，要么停止更新了，要么具有局限性。读者对其感兴趣，可以自行去了解。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;现有的SQL解决方案通常都不是水平可伸缩的，因此当数据量变大时会遇到障碍。但是这样的情况，随着NoSQL的出现已经得到很大程度的缓解，并且随着NoSQL技术的完善与成熟，这种情况将会从根本上解决。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.edagarli.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="HBase" scheme="http://blog.edagarli.com/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>我的创业反思</title>
    <link href="http://blog.edagarli.com/2016/02/09/%E5%88%9B%E4%B8%9A%E5%8F%8D%E6%80%9D/"/>
    <id>http://blog.edagarli.com/2016/02/09/创业反思/</id>
    <published>2016-02-09T13:35:00.000Z</published>
    <updated>2016-03-19T12:38:37.000Z</updated>
    
    <content type="html">&lt;p&gt;往往夜深人静的时候，容易胡思乱想。但今天不知为何，躺在床上不停的回忆创业往事，感觉有点过头了。可能与今天的心情，或者与看到的事情有关。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我当时进入公司作为技术合伙人的时候，公司正进行新的产品研发。不过之前公司已经开发了一款产品，所以团队开发能力还是有的（虽然人员变换频繁，不过还是很理解的，毕竟是创业公司）。先不说新产品市场，前景如何如何，此时公司内部问题还是有很多的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一：选错人；我进入公司时候，原先主力iOS没干了（其实之前也是外包，做完就撤），剩下的是CEO招进来的，招了几个看上去还不错的iOS程序员。由于CEO也不是技术出身，所以说招进来的靠不靠谱也不是很清楚。按照以往我的习惯，我要了解一个人，我就网络搜索，爬虫等。还是挖到了一些有用的信息，iOS开发竟是培训机构出来的。之前谎称是有2年工作经验的。这块我找CEO聊了聊，但是人不好找，新产品开发时间紧，迫于无赖。暂时先留着，开发新产品。（其实，这里已经埋下了隐患）&lt;/p&gt;
&lt;p&gt;第二：没有产品经理。其实这也不是大问题，CEO往往前期可以充当产品经理。无奈，CEO之前是搞投资的，对产品经验欠缺。刚开始，我们是3个合伙人。CEO，我，还有一个负责运营的。新产品需求我们开始一起商量定的。说实话，到现在我还觉得，产品完全是我们闭着脑袋想出来的，产品设计不是很合理，没有充分的考虑市场，用户，这才导致产品上线用户黏性很低。&lt;/p&gt;
&lt;p&gt;第三：管理不行。大将无能，累死三军！这句话说的真好。往往下面出问题了，首先需要反思的是自己。所以说当你选错人后，如何管理，如何带人，这也是一种考验。一句话，没管理好。iOS开发进度一直落后，产品效果也不好。但我们就是不敢开除，因为不好找人啊！（我相信创业公司都如此）中间，其实建立了很多方式，绩效考核，绩效奖金等。现在，如果让我选择的话，我立刻开除。产品最终出来花的时间有点长，导致我们资金花了很大一部分。这就导致融资的急迫性。最终运营一段时间，因为资金链断了，团队解散了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;心里有很多关于自己创业的话说，可能是因为表达不行，可能是有些东西不知道从哪去讲。反正现在回忆起来，总觉得当时能做的太多了，但就是没做；总觉得当时不该犯的错误，就犯了；总觉得当时能考虑全很多事情，但就是没有；总觉得当时应该清醒一点，不要盲目闭门想着产品，但还是盲目了；总觉得产品做出来后，就很火了，但终究没有；总觉得……&lt;br&gt;自己想到哪，写到哪。总感觉肚子里好多东西要写，但终究写不出来。想对那些一直在创业路上的朋友们，说两个字: 加油！&lt;/p&gt;
&lt;p&gt;如果觉得有点帮助，可以赏点酒钱！（lizhi@lydiabox.com）&lt;br&gt;&lt;img src=&quot;/images/aex068188cqwy9xbxa3oc07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;往往夜深人静的时候，容易胡思乱想。但今天不知为何，躺在床上不停的回忆创业往事，感觉有点过头了。可能与今天的心情，或者与看到的事情有关。&lt;/p&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.edagarli.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="创业" scheme="http://blog.edagarli.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
</feed>
