<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> spring data redis源码分析 · Edagarli's Blog</title><meta name="description" content="spring data redis源码分析 - Edagarli"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/edagarli" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/edagarli" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://t.cn/RqJwVLs" target="_blank" class="nav-list-link">经历</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">spring data redis源码分析</h1><div class="post-time">2016年1月9日</div><div class="post-content"><p>既然涉及到源码分析，最好的方式就是去看开源出来的代码。</p>
<p><a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="external">https://github.com/spring-projects/spring-data-redis</a></p>
<a id="more"></a>
<p>简单介绍下，Spring-data-redis为spring-data模块中对redis的支持部分，简称为“SDR”，提供了基于jedis客户端API的高度封装以及与spring容器的整合。</p>
<p>下面是spring data redis class diagram。</p>
<p><img src="/images/1.jpg" alt=""></p>
<p>简单的说：</p>
<p>1.提供了一个高度封装的“RedisTemplate”类，进行了连接池自动管理。</p>
<p>如果你使用过jedisPool连接池，在数据操作之前，你需要pool.getResource()即从连接池中获取“链接资源”(Jedis),在操作之后，你需要(必须)调用pool.returnResource()将资源归还个连接池。但是，spring-data-redis中，我们似乎并没有直接操作pool，那么spring是如何做到pool管理的呢？？一句话：spring的“看门绝技”–callback。<br> public <t> T execute(RedisCallback<t> action)：这个方法是redisTemplate中执行操作的底层方法，任何基于redisTemplate之上的调用(比如，valueOperations)最终都会被封装成RedisCallback，redisTemplate在execute方法中将会直接使用jedis客户端API进行与server通信，而且在如果使用了连接池，则会在操作之后执行returnSource。</t></t></p>
<p>2.同时针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</p>
<p>ValueOperations：简单K-V操作<br>SetOperations：set类型数据操作<br>ZSetOperations：zset类型数据操作<br>HashOperations：针对map类型的数据操作<br>ListOperations：针对list类型的数据操作</p>
<p>3.源码中你可以发现RedisSerializer接口，其实是针对数据的“序列化/反序列化”做了处理。</p>
<p>JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream/ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。<br>StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“new String(bytes, charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。<br>JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。【需要jackson-mapper-asl工具支持】<br>OxmSerializer：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。【需要spring-oxm模块的支持】<br>    针对“序列化和发序列化”中JdkSerializationRedisSerializer和StringRedisSerializer是最基础的策略，原则上，我们可以将数据存储为任何格式以便应用程序存取和解析(其中应用包括app，hadoop等其他工具)，不过在设计时仍然不推荐直接使用“JacksonJsonRedisSerializer”和“OxmSerializer”，因为无论是json还是xml，他们本身仍然是String。<br>    如果你的数据需要被第三方工具解析，那么数据应该使用StringRedisSerializer而不是JdkSerializationRedisSerializer。<br>    如果你的数据格式必须为json或者xml，那么在编程级别，在redisTemplate配置中仍然使用StringRedisSerializer，在存储之前或者读取之后，使用“SerializationUtils”工具转换转换成json或者xml。</p>
<p>如果觉得还不错，赏点酒钱！</p>
<p><img src="/images/aex068188cqwy9xbxa3oc07.png" alt=""></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/17/高可用可伸缩架构实用经验谈/" class="prev">上一篇</a><a href="/2016/01/09/spring-data-redis与jedis比较/" class="next">下一篇</a></div><div data-thread-key="2016/01/09/spring-data-redis源码分析/" data-title="spring data redis源码分析" data-url="http://blog.edagarli.com/2016/01/09/spring-data-redis源码分析/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"edagarli"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://blog.edagarli.com">Edagarli</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src ="//hm.baidu.com/hm.js?47be17dedd3258963b6518c2ffbd5e1d";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>