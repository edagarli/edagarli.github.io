<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 读书笔记之HBase数据模型 · Edagarli's Blog</title><meta name="description" content="读书笔记之HBase数据模型 - Edagarli"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/edagarli" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/edagarli" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://t.cn/RqJwVLs" target="_blank" class="nav-list-link">经历</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">读书笔记之HBase数据模型</h1><div class="post-time">2016年1月21日</div><div class="post-content"><p>HBase 是一种面向列的分布式的数据库,其物理模型和逻辑模型与传统的关系型数据库有很大的不同。下面我们将详细讲述 HBase 数据模型中的一些重要概念。</p>
<a id="more"></a>
<h2 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h2><h3 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h3><pre><code> HBase 是一个类似GoogleBigTable 的开源分布式数据库,大部分特性和 BigTable 相同, 可以理解为是一个稀疏的、长期存储的、多维度的和排序的映射表,表中的每一行可以有不同的列。与关系型数据库不同,关系型数据库要求表在被创建时明确定义列以及列的数据类型,而 HBase 的同一个表的纪录可以有不一样的列。

HBase中最基本的单位是列,一列或者多列构成了行,行有行键(Rowkey), 每一行的行键都是唯一的,相同行键的插入操作被认为是对同一行的操作,也就是说如果做了两次写入操作,而行键是同一个,那么后面的操作可以认为是对该行的某些列的更新操作。
</code></pre><h3 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h3><pre><code>虽然在逻辑模型中,表可以被看成一个稀疏的行的集合。但在物理上,表是按列分开存储的。HBase 的列是按列族分组的,HFile 是面向列的,存放行的不同列的物理文件,一个列 族的数据存放在多个 HFile 中,最重要的是一个列族的数据会被同一个 Region 管理,物理上 存放在一起。Region 是管理 HFile 的一种机制。
</code></pre><h2 id="数据模型的重要概念"><a href="#数据模型的重要概念" class="headerlink" title="数据模型的重要概念"></a>数据模型的重要概念</h2><pre><code>HBase同一列可以存储不同时刻的值，同时多个列可以组成一个列族（Colummn Family）。
</code></pre><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><pre><code>表名通常使用 Java String 类型或 byte[](二进 数组)表示, 表名作为 HDFS 存储  的一部分来使用,因此必须要符合文件名规范,所以构成表名的字符是有限制的。可以直接查看底层存储系统,在 HDFS 中可以看到每个表的表名都作为独立的目录结构,在某些情况下,用户可能需要查看这部分信息。
</code></pre><h3 id="行键"><a href="#行键" class="headerlink" title="行键"></a>行键</h3><pre><code>行键,即Rowkey,是 HBase 中最为重要的概念之一，行键是不可分割的字节数组。行键是按字典顺序由低到高存储在表中的,以一个空的数组来标识表空间的起始或者结尾。
 为了高效检索数据,应该仔细设计 Rowkey 以获得最高的查询性能 首先 Rowkey 被冗余存储,所以长度不宜过长,过长的 Rowkey 将会占用大量的空间同时会降低检索效率 ;其 次 Rowkey 应该尽量分布均匀 ,这样不会产生热点现象 ；最后是 Rowkey  唯一原则 ,  必须在设计上保证其唯 一性。
</code></pre><h3 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h3><pre><code>HBase 中的列族是一些列的集合。一个列族中所有列成员有着相同的前缀。

在创建表的时候至少要指定一个列族,新的列族可以随后按需、动态地加入,但是修改列族要先停用表。应该将经常一起查询的列放在一个列族中,合理划分列族将减少查询时加载到缓存的数据,提高查询的效率,但也不要有 太多的列族,因为夸列族访问是非常低效的。
</code></pre><h3 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h3><pre><code>HBase 中的单元格由行键、列族、列、时间戳唯一确定。
</code></pre><h2 id="数据模型的操作"><a href="#数据模型的操作" class="headerlink" title="数据模型的操作"></a>数据模型的操作</h2><pre><code>HBase对数据模型的4个主要操作包括Get，Put，Scan和Delete。这里需要注意的是Delete操作并不是真正地从磁盘删除数据。而是通过创建墓碑标志进行处理。这些墓碑标记的值和小于该时间版本的单元格在大合并时被清除。
</code></pre><h2 id="数据模型的特殊属性"><a href="#数据模型的特殊属性" class="headerlink" title="数据模型的特殊属性"></a>数据模型的特殊属性</h2><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><pre><code>HBase 是否支持连接查询, 即Join 查询,是一个常见问题。简单来说是不支持,至少不像传统 RDBMS 那样支持。
</code></pre><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><pre><code>IncrementColumnValue(ICV)是 HBase 的计数器,可以使用它完成一些诸如计算页面浏览量(PV)的操作。ICV 操作发生在 RegionServer 上,而不是在客户端,所以速度快,使用方式也没有那么繁琐。
</code></pre><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><pre><code>HBase API 中 put()、delete()、checkAndPut() 等修改操作是独立执行的,这意味着在一个串行方式的执行中,对于每一行必须保证行级别的操作是原子性的。
</code></pre><h3 id="自动分区"><a href="#自动分区" class="headerlink" title="自动分区"></a>自动分区</h3><pre><code>可以动态扩展并且 HBase 保证 Region 的负载均衡。
</code></pre><hr>
<p>更多书籍读书笔记请参看</p>
<p><a href="https://github.com/edagarli/ReadingNotes" target="_blank" rel="external">https://github.com/edagarli/ReadingNotes</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/21/读书笔记之Java程序性能优化/" class="prev">上一篇</a><a href="/2016/01/20/读书笔记之认识HBase/" class="next">下一篇</a></div><div data-thread-key="2016/01/21/读书笔记之HBase数据模型/" data-title="读书笔记之HBase数据模型" data-url="http://blog.edagarli.com/2016/01/21/读书笔记之HBase数据模型/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"edagarli"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://blog.edagarli.com">Edagarli</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src ="//hm.baidu.com/hm.js?47be17dedd3258963b6518c2ffbd5e1d";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>